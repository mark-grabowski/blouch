---
title: "Generative mvOUOU Script"
output: html_notebook
editor_options: 
  chunk_output_type: console
---
########################################################################################################################
Generate OUOU data with known parameter values and then use to test mvBlouchOUOU stan code
```{r}
rm(list=ls())
library(MASS)
library(rstan)
library(ggplot2)
library(dplyr)
library(tidybayes) # For spread_draws, median_qi
library(tidyr)     # For crossing, pivot_longer
library(ggsci)     # For AAAS colors
library(truncnorm)
library(matrixcalc)
library(phytools)
library(blouch)

#install.packages("expm")
#install.packages("matrixcalc")
library(expm)
######################################################################################################################
source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/root_trace.R')
source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/sim_mvOU.R')
source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/set.converge.regimes.redux.R')
source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/root_trace_redux.R')

######################################################################################################################
#For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores())
#options(mc.cores = 8)
rstan::rstan_options(auto_write = TRUE)

dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars")
if (!file.exists(M)) file.create(M)
arch <- ifelse(R.version$arch == "aarch64", "arm64", "x86_64")
cat(paste("\nCXX14FLAGS += -O3 -mtune=native -arch", arch, "-ftemplate-depth-256"),
    file = M, sep = "\n", append = FALSE)

```

Generate Phylogeny based on subset 10K Primate Phylogeny
```{r}
N<-30 #Number of species
n_traits <- 2
set.seed(10) #Set seed to get same random species each time

phy <- ape::keep.tip(tree.10K,sample(tree.10K$tip.label)[1:N]) 
phy<-ape::multi2di(phy)

l.tree<-max(ape::branching.times(phy)) ## rescale tree to height 1
phy$edge.length<-phy$edge.length/l.tree 

tip.label<-phy$tip.label
plot(phy)
nodelabels(frame = "n", cex = 0.8, col = "blue")
tiplabels(frame = "n", cex = 0.8, col = "blue")
#phytools::phenogram(phy,X,spread.labels=TRUE,spread.cost=c(1,0)) #Plot X data

plot(phy,no.margin=TRUE,edge.width=2,cex=0.7)
ape::nodelabels(frame="none",adj=c(1.1,-0.4))
ape::tiplabels()

shifts<-c(56) #Location of nodes with regime shifts
trdata<-data.frame(phy$tip.label)
trdata<-treeplyr::make.treedata(phy,trdata)
trdata<-set.converge.regimes.redux(trdata,shifts)


```

```{r}
paths<-root_trace_redux(trdata,N) #Calculate paths from tips to root with OUs and branch lengths for each segment
z_0<-c(2,6)
OU_mat<-data.frame(matrix(c(3,7,
              4,8), nrow = 2, byrow = TRUE))

rownames(OU_mat)<-c("OU1","OU2")
colnames(OU_mat)<-c("Trait1","Trait2")

F_mat<-matrix(c(0.5,0,
              0,0.7), nrow = 2, byrow = TRUE)

Sigma<-matrix(c(0.1,0,
              0,0.25), nrow = 2, byrow = TRUE)

sim_EY_V_true<-sim_mvOU(phy,paths,z_0,OU_mat,F_mat,Sigma) #Send function paths output, ancestral traits value, and optima values

```


```{r}
true_EY<-unlist(lapply(sim_EY_V_true[[1]],as.vector)) #First make sure list is treated as vector, then flatten
true_V<-sim_EY_V_true[[2]]

y_true<-mvrnorm(n=1, mu = true_EY , Sigma = true_V)

y_true <- matrix(y_true , nrow = N, ncol = n_traits, byrow = TRUE)
rownames(y_true) <- phy$tip.label
colnames(y_true) <- paste0("Trait", 1:n_traits) #No separator by default

y_error_sd <- 0.1 # Assumed SD of measurement error for x
y_obs <- y_true + rnorm(N*n_traits, 0, y_error_sd)

```

Create ragged data structure for Stan using root_trace_redux output
```{r}

path_nodes <- c() #Node paths
path_nodes_idx <- c() #Group sizes
regimes <- c()
regimes_idx <- c()
branch_lengths <- c()
branch_lengths_idx <- c()

for(i in 1:N){
  path_nodes <- c(path_nodes, paths[[1]][[i]])
  path_nodes_idx <- c(path_nodes_idx , length(paths[[1]][[i]]))
}

for(i in 1:N){
  regimes <- c(regimes, paths[[2]][[i]]) #Vector of regimes
  regimes_idx <- c(regimes_idx , length(paths[[2]][[i]])) #Ids for which regimes are on which branches (length of regimes for each branch)
  branch_lengths <- c(branch_lengths, paths[[3]][[i]]) #Vector of branch lengths
  branch_lengths_idx <- c(branch_lengths_idx , length(paths[[3]][[i]])) #Which branches refer to which path
}


```




Calculte C matrix, other parameters
```{r}
mrca1 <- ape::mrca(phy) #Node numbers for MRCA of tips
t_node <- ape::node.depth.edgelength(phy) #Time from root to node, starting with the tips
t_root_MRCA <- matrix(t_node[mrca1], nrow=N, dimnames = list(phy$tip.label, phy$tip.label)) #Matrix with time from root to MRCA of pairs of tips - pulls out values of times that correspond with node numbers - integers
t_tips <- t_node[1:N] #Times from root for tips
t_MRCA_tips <- t_tips - t_root_MRCA #Times from root to tips - times from root to MRCA = times from MRCA to tips = Cij
lambda_min_from_halflife = log(2) / 3; # Calculate lambda_min based on half-life of 3
#log_lambda_min_for_stan = log(lambda_min_from_halflife);

```


Setup for mvBlouchOU analysis
```{r}
dat <- list(
  N = N,
  n_traits = n_traits,
  n_branches = length(branch_lengths),
  n_path_nodes = length(path_nodes),
  n_regs = dim(OU_mat)[2],
  y_obs = as.matrix(y_obs),
  y_error = matrix(rep(y_error_sd,N*n_traits),nrow=N,ncol=n_traits,byrow=FALSE),
  path_nodes = path_nodes,
  path_nodes_idx  = path_nodes_idx,
  regimes = as.numeric(sub("OU", "", regimes)),
  regimes_idx = regimes_idx,
  branch_lengths = branch_lengths,
  branch_lengths_idx = branch_lengths_idx,
  OU_mat = OU_mat,
  t_MRCA_tips = t_MRCA_tips,
  t_root_MRCA = t_root_MRCA#,
  #log_lambda_min_val = log_lambda_min_for_stan
  )

```

To visually explore what your priors look like, you can simulate a large number of samples from each prior distribution specified in your Stan model and then plot their densities or histograms.

This helps you:
1.  **Understand the implications of your prior choices**: Are they placing mass where you expect? Are they too broad or too narrow?
2.  **Diagnose potential issues**: For instance, if a scale parameter prior allows for extremely small values, it can lead to numerical instability.

Below is R code to do this. I'll assume `n_traits = 2` as per your simulation setup, and use standard `ggplot2` for plotting.

```{r}

# Load necessary libraries
library(ggplot2)
library(rstan) # For rlkjcorr
library(bayesplot) # Optional, but good for diagnostics later
library(dplyr)
library(tidyr)
library(ggsci) # For nice color palettes
library(rethinking)
# Set a seed for reproducibility of prior simulations
#set.seed(123)

# Define common parameters for visualization
n_traits <- 2
n_prior_samples <- 50000 # Number of samples to draw from each prior

# Define a nice color palette
mypal <- ggsci::pal_npg("nrc", alpha = 0.6)(2)
mypal_dark <- ggsci::pal_npg("nrc", alpha = 0.9)(2)

cat("--- Visualizing Priors ---\n\n")

# --- 1. y_0_ancestral ~ normal(0, 1) ---
y0_ancestral_samples<-c()
for(i in 1:n_traits){
  y0_ancestral_samples<-c(y0_ancestral_samples,rnorm(n_prior_samples * n_traits, mean = mean(y_obs[,i]), 1)) #sd = sd(y_obs[,i])))
}

y0_ancestral_df <- data.frame(
  value = y0_ancestral_samples,
  trait = rep(paste0("Trait ", 1:n_traits), each = n_prior_samples * n_traits)
)

p1 <- ggplot(y0_ancestral_df, aes(x = value, fill = trait, color = trait)) +
  geom_density(alpha = 0.5, size = 0.8) +
  geom_density(alpha = 0.5, size = 0.8) +

  scale_fill_manual(values = mypal) +
  scale_color_manual(values = mypal_dark) +
  labs(
    title = "Prior: y_0_ancestral ~ Normal(mean(y_obs[,j]), sd(y_obs[,j]))",
    x = "Value",
    y = "Density"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

print(p1)
cat("\nPrior for y_0_ancestral: Centered at 0, unit variance. Generally a weak prior.\n")

# --- 2. lambdas 
log_lambdas_samples <- rnorm(n_prior_samples*n_traits,log(0.5),1.0)
lambdas_samples <- exp(log_lambdas_samples)

lambdas_df <- data.frame(
  value = lambdas_samples,
  trait = rep(paste0("Trait ", 1:n_traits), each = n_prior_samples)
)

p2 <- ggplot(lambdas_df, aes(x = value, fill = trait, color = trait)) +
  geom_density(alpha = 0.5, size = 0.8) +
  scale_fill_manual(values = mypal) +
  scale_color_manual(values = mypal_dark) +
  labs(
    title = "Prior: lambdas ~ exp(normal(log(0.5),1.0))",
    x = "Value",
    y = "Density"
  ) +
  xlim(0, 3) + # Extend slightly beyond 2 to show cutoff
  geom_vline(xintercept = 2, linetype = "dashed", color = "red", size = 1) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

print(p2)

# --- 2. half lives
hl_samples_df <- data.frame(
  value = log(2)/lambdas_samples,
  trait = rep(paste0("Trait ", 1:n_traits), each = n_prior_samples)
)

p2 <- ggplot(hl_samples_df, aes(x = value, fill = trait, color = trait)) +
  geom_density(alpha = 0.5, size = 0.8) +
  scale_fill_manual(values = mypal) +
  scale_color_manual(values = mypal_dark) +
  labs(
    title = "Prior: hl ~ log(2)/exp(normal(log(0.5),1.0))",
    x = "Value",
    y = "Density"
  ) +
  xlim(0, 6) + # Extend slightly beyond 2 to show cutoff
  geom_vline(xintercept = 3, linetype = "dashed", color = "red", size = 1) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

print(p2)

# --- 3. sigma_P ~ normal(0, 0.5) [implicitly half-normal due to lower=0] ---
sigma_P_samples <- abs(rnorm(n_prior_samples * n_traits, mean = 0, sd = 0.5))
sigma_P_df <- data.frame(
  value = sigma_P_samples,
  trait = rep(paste0("Trait ", 1:n_traits), each = n_prior_samples)
)

p3 <- ggplot(sigma_P_df, aes(x = value, fill = trait, color = trait)) +
  geom_density(alpha = 0.5, size = 0.8) +
  scale_fill_manual(values = mypal) +
  scale_color_manual(values = mypal_dark) +
  labs(
    title = "Prior: sigma_P ~ Half-Normal(0, 0.5)",
    x = "Value",
    y = "Density"
  ) +
  xlim(0, max(sigma_P_df$value) * 1.05) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

print(p3)
cat("\nPrior for sigma_P: Half-Normal(0, 0.5) puts most mass near 0 but allows for larger values.\n")


# --- 4. sigma_Sigma ~ normal(0, 0.5) [implicitly half-normal due to lower=0] ---
sigma_Sigma_samples <- abs(rnorm(n_prior_samples * n_traits, mean = 0, sd = 0.5))
sigma_Sigma_df <- data.frame(
  value = sigma_Sigma_samples,
  trait = rep(paste0("Trait ", 1:n_traits), each = n_prior_samples)
)

p4 <- ggplot(sigma_Sigma_df, aes(x = value, fill = trait, color = trait)) +
  geom_density(alpha = 0.5, size = 0.8) +
  scale_fill_manual(values = mypal) +
  scale_color_manual(values = mypal_dark) +
  labs(
    title = "Prior: sigma_Sigma ~ Half-Normal(0, 0.5)",
    x = "Value",
    y = "Density"
  ) +
  xlim(0, max(sigma_Sigma_df$value) * 1.05) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

print(p4)
cat("\nPrior for sigma_Sigma: Similar to sigma_P, a Half-Normal(0, 0.5).\n")

# --- 5. Omega_P ~ lkj_corr(20) and Omega_Sigma ~ lkj_corr(10) ---
# For n_traits = 2, a correlation matrix only has one unique correlation coefficient: rho_12
# We can plot the density of this correlation.
Omega_P_samples <- rlkjcorr(n_prior_samples, n_traits, eta = 20)
Omega_Sigma_samples <- rlkjcorr(n_prior_samples, n_traits, eta = 10)

# Extract the correlation coefficient (element [1,2])
corr_P_samples <- sapply(Omega_P_samples, function(m) m[1,2])
corr_Sigma_samples <- sapply(Omega_Sigma_samples, function(m) m[1,2])

# Combine for plotting
corr_df <- data.frame(
  value = c(corr_P_samples, corr_Sigma_samples),
  prior = factor(c(rep("Omega_P (eta=20)", n_prior_samples),
                   rep("Omega_Sigma (eta=10)", n_prior_samples)))
)

p5 <- ggplot(corr_df, aes(x = value, fill = prior, color = prior)) +
  geom_density(alpha = 0.5, size = 0.8) +
  scale_fill_manual(values = c(mypal[1], mypal[2])) +
  scale_color_manual(values = c(mypal_dark[1], mypal_dark[2])) +
  labs(
    title = "Priors: LKJ Correlation Matrices",
    subtitle = "Density of correlation coefficient (rho_12)",
    x = "Correlation Coefficient",
    y = "Density"
  ) +
  xlim(-1, 1) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

print(p5)
cat("\nPriors for Omega_P (eta=20) and Omega_Sigma (eta=10): LKJ_corr(eta) concentrates probability around identity (zero correlation) as eta increases.\n")
cat("Eta=20 is a strong prior for zero correlation, Eta=10 is slightly weaker.\n")

# --- 6. y_true_raw ~ normal(0, 1) (if using non-centered parameterization) ---
y_true_raw_samples <- rnorm(n_prior_samples, mean = 0, sd = 1)
y_true_raw_df <- data.frame(value = y_true_raw_samples)

p6 <- ggplot(y_true_raw_df, aes(x = value)) +
  geom_density(fill = mypal[1], color = mypal_dark[1], alpha = 0.6) +
  labs(
    title = "Prior: y_true_raw ~ Normal(0, 1) (Non-Centered)",
    x = "Value",
    y = "Density"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

print(p6)
cat("\nPrior for y_true_raw: Standard Normal. This is the 'raw' component when using non-centered parameterization.\n")

cat("\n--- End of Prior Visualization ---\n")
```


Two chains
```{r}
setwd('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/')
rstan::stanc('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/mvBlouchOU.stan')
stan_file<-"mvBlouchOU.stan"

stan_model<-rstan::stan_model(file=stan_file) # Compile the Stan model (this takes time the first time)

create_init_fun <- function(stan_data_list) {
  function() {
    N_val <- stan_data_list$N
    n_traits_val <- stan_data_list$n_traits
    y_obs_val <- stan_data_list$y_obs

    # y_true_raw (continue to randomize around 0,1)
    y_true_raw_init_val <- matrix(rnorm(N_val * n_traits_val, mean = 0, sd = 1),
                                  nrow = N_val, ncol = n_traits_val, byrow = TRUE)

    # mu_y_true_param (initialize near observed mean)
    mu_y_true_param_init_val <- apply(y_obs_val, 2, mean) + rnorm(n_traits_val, 0, 0.1)

    # Fixed safe initial values for log_sigma_y_true
    log_sigma_y_true_init_val <- rep(log(0.8), n_traits_val) # log(0.8) is approx -0.22, a reasonable mid-range value

    # y_0_ancestral_raw (continue to randomize around 0,1)
    y_0_ancestral_raw_init_val <- rnorm(n_traits_val, mean = 0, sd = 1)

    # mu_y_0_ancestral (initialize near observed mean)
    mu_y_0_ancestral_init_val <- apply(y_obs_val, 2, mean) + rnorm(n_traits_val, 0, 0.1)

    # Fixed safe initial values for log_sigma_y_0_ancestral
    log_sigma_y_0_ancestral_init_val <- rep(log(0.8), n_traits_val) # log(0.8) is approx -0.22

    # CRITICAL: Fixed, safe initial values for the key matrix parameters
    #lambdas_init_val <- rep(1.0, n_traits_val)     # Fixed at 1.0 (mid-range of [0,2])
    log_lambdas_init_val <- runif(n_traits_val, log(0.5), log(1.5)) # Adjust range as needed
    Omega_P_init_val <- diag(n_traits_val)         # Identity matrix (no correlation)
    sigma_P_init_val <- rep(0.7, n_traits_val)     # Fixed at 0.7 (mid-range of 0.5-1.0)
    Omega_Sigma_init_val <- diag(n_traits_val)     # Identity matrix (no correlation)
    sigma_Sigma_init_val <- rep(0.7, n_traits_val) # Fixed at 0.7 (mid-range of 0.5-1.0)


    return(list(
      y_true_raw = y_true_raw_init_val,
      mu_y_true_param = mu_y_true_param_init_val,
      log_sigma_y_true = log_sigma_y_true_init_val,
      y_0_ancestral_raw = y_0_ancestral_raw_init_val,
      mu_y_0_ancestral = mu_y_0_ancestral_init_val,
      log_sigma_y_0_ancestral = log_sigma_y_0_ancestral_init_val,
      log_lambdas = log_lambdas_init_val,
      Omega_P = Omega_P_init_val,
      sigma_P = sigma_P_init_val,
      Omega_Sigma = Omega_Sigma_init_val,
      sigma_Sigma = sigma_Sigma_init_val
    ))
  }
}
```

Debug
```{r}
# Create the actual init function that Stan will call
my_init_fun <- create_init_fun(dat)

stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    init = my_init_fun,
    chains = 1, # Keep at 1 for faster debugging iterations
    cores = 1,   # Keep at 1 core since you're using 1 chain
    iter = 500, # Keep iterations lower for faster testing
    control = list(adapt_delta = 0.999, max_treedepth = 20) # <--- IMPORTANT: KEEP THESE ENABLED
)
```

```{r}
# Create the actual init function that Stan will call
my_init_fun <- create_init_fun(dat)

stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    init = my_init_fun,
    chains = 1, # Keep at 1 for faster debugging iterations
    cores = 1,   # Keep at 1 core since you're using 1 chain
    iter = 500, # Keep iterations lower for faster testing
    #control = list(adapt_delta = 0.999, max_treedepth = 20) # <--- IMPORTANT: KEEP THESE ENABLED
)
```


No initial values
```{r}

stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    chains = 1, # Keep at 1 for faster debugging iterations
    cores = 1,   # Keep at 1 core since you're using 1 chain
    iter = 1000 # Keep iterations lower for faster testing
    #,control = list(adapt_delta = 0.95)
                   #, max_treedepth = 20) # <--- IMPORTANT: KEEP THESE ENABLED
    #control = list(adapt_delta = 0.999, max_treedepth = 20) # <--- IMPORTANT: KEEP THESE ENABLED
)
```


# Posteriors
```{r}
print(stan_fit,
      pars = c("F_mat", "Sigma" 
               ), 
      probs = c(0.025, 0.25, 0.5, 0.75, 0.975), # Default quantiles
      digits_summary = 2) # Adjust number of digits if needed

#rstan::traceplot(stan_fit, pars = c("beta","alpha","theta[1]","es","sd_theta[1]","sd_e[1]"))

post<-rstan::extract(stan_fit)
```


```{r}
library(bayesplot)

# Assuming 'stan_fit' is the object from your last successful run
mcmc_pairs(stan_fit,
           pars = c("y_0_ancestral[1]", "y_0_ancestral[2]",
                    "lambdas[1]", "lambdas[2]", # Now using 'lambdas' which is exp(log_lambdas)
                    "Omega_P[1,2]",
                    "sigma_P[1]", "sigma_P[2]",
                    "Omega_Sigma[1,2]",
                    "sigma_Sigma[1]", "sigma_Sigma[2]",
                    "F_mat[1,1]", "F_mat[2,2]", "F_mat[1,2]",
                    "log_sigma_y_true[1]", "log_sigma_y_true[2]",
                    "log_sigma_y_0_ancestral[1]", "log_sigma_y_0_ancestral[2]",
                    "lp__" # Always include lp__ to see if divergences cluster with low likelihood
                    ),
           diag_fun = "dens", off_diag_fun = "scatter", np = nuts_params(stan_fit))
```


```{r}
library(bayesplot)

# For n_traits = 2, you'll typically have two elements for vectors like lambdas.
# For correlation matrices (Omega_P, Omega_Sigma), you only need to plot one off-diagonal element, e.g., [1,2].
# For F_mat, plot the diagonal and one off-diagonal.

mcmc_pairs(stan_fit,
           pars = c("y_0_ancestral[1]", "y_0_ancestral[2]",
                    "lambdas[1]", "lambdas[2]",
                    "Omega_P[1,2]", # Or "Omega_P[2,1]" as it's symmetric
                    "sigma_P[1]", "sigma_P[2]",
                    "Omega_Sigma[1,2]", # Or "Omega_Sigma[2,1]"
                    "sigma_Sigma[1]", "sigma_Sigma[2]",
                    "F_mat[1,1]", "F_mat[2,2]", "F_mat[1,2]"), # Include key elements of F_mat
           diag_fun = "dens",
           off_diag_fun = "scatter",
           np = nuts_params(stan_fit))
```


Plotting posterior vs prior for R Matrix
```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(tidybayes) # For spread_draws, gather_draws, median_qi

# Assuming stan_fit is your fitted Stan model object from the previous run

# Extract posterior samples for R directly
# The `gather_draws` function from tidybayes is great for this.
# It automatically converts to a long format suitable for ggplot.
R_posterior_long <- stan_fit %>%
  gather_draws(R[i, j]) %>% #i and j are placeholders for variables
  ungroup() %>% # Remove grouping for easier manipulation
  select(-.chain, -.iteration, -.draw) # Remove internal tidybayes columns if not needed

# Rename columns for clarity
R_posterior_long <- R_posterior_long %>%
  rename(trait1 = i, trait2 = j, value = .value) %>%
  mutate(
    parameter_name = paste0("R[", trait1, ",", trait2, "]"),
    type = "Posterior"
  )

# You'll also need the values of `sigma_R` and `Omega` for the prior (if we simulate from them)
# For now, let's focus on R directly.
```

```{r}

# --- 3. Define the function to simulate R from its Prior ---
# This function simulates from the priors on sigma_R (half-normal) and Omega (correlation matrix).
# NOTE: The correlation matrix simulation (Omega_prior) here uses a heuristic
# (cov2cor(tcrossprod(Z))) because `rlkjcorr` is not available in rstan.
# This heuristic produces valid random correlation matrices, but might not
# precisely match the `lkj_corr(2)` prior for Omega as closely as a dedicated LKJ sampler.
# However, it provides a valuable visual comparison.
simulate_R_prior <- function(n_traits, sigma_prior_sd) {
  # 1. Generate a random correlation matrix (Omega_prior)
  # This method generates a random positive definite matrix and then normalizes it.
  Z <- matrix(rnorm(n_traits * n_traits), n_traits, n_traits)
  Omega_prior <- cov2cor(tcrossprod(Z))

  # 2. Simulate sigma_R from a half-normal prior (abs of normal)
  # Your Stan model uses sigma_R ~ normal(0, 1), which for a <lower=0>
  # constraint means it's a half-normal(0,1).
  sigma_R_prior <- abs(rnorm(n_traits, 0, sigma_prior_sd))

  # 3. Construct the R matrix from sigma_R and Omega
  R_mat <- diag(sigma_R_prior) %*% Omega_prior %*% diag(sigma_R_prior)
  return(R_mat)
}

# --- 4. Generate Prior Samples for R ---
n_prior_samples <- 4000 # Number of prior samples to generate for smooth density

R_prior_list <- list()
for (s in 1:n_prior_samples) {
  R_prior_list[[s]] <- simulate_R_prior(
    n_traits = dat$n_traits,      # Using n_traits from your data list
    sigma_prior_sd = sigma_R_prior_sd            #
  )
}

# Convert prior samples to a long format similar to the posterior
# This part is specifically for n_traits = 2. For larger n_traits,
# you'd need a more generic way to flatten each R_mat, e.g., using `as.vector`
# and then recreating indices.
R_prior_long <- bind_rows(lapply(1:n_prior_samples, function(s) {
  R_mat <- R_prior_list[[s]]
  tibble(
    value = c(R_mat[1,1], R_mat[1,2], R_mat[2,1], R_mat[2,2]),
    trait1 = rep(c(1,1,2,2), length.out = length(value)),
    trait2 = rep(c(1,2,1,2), length.out = length(value)),
    sample_id = s
  )
})) %>%
  mutate(
    parameter_name = paste0("R[", trait1, ",", trait2, "]"),
    type = "Prior"
  ) %>%
  select(-sample_id) # Remove sample_id once converted

# --- 5. Combine Posterior and Prior Data for Plotting ---
plot_data_R <- bind_rows(R_posterior_long, R_prior_long)
```

```{r}

# --- 6. Plotting with ggplot2 (Corrected for linewidth) ---
# Define a custom color palette for Prior and Posterior
my_colors <- c("Prior" = "skyblue", "Posterior" = "darkred")

# Order the facets for better presentation (optional: diagonals first, then off-diagonals)
plot_data_R$parameter_name <- factor(plot_data_R$parameter_name,
                                     levels = c("R[1,1]", "R[2,2]", "R[1,2]", "R[2,1]"))

# Create a data frame for true R values to add as vertical lines
true_R_values_df <- data.frame(
  parameter_name = factor(c("R[1,1]", "R[2,2]", "R[1,2]", "R[2,1]"),
                          levels = c("R[1,1]", "R[2,2]", "R[1,2]", "R[2,1]")),
  true_value = c(R_true[1,1], R_true[2,2], R_true[1,2], R_true[2,1])
)


ggplot(plot_data_R, aes(x = value, fill = type, color = type)) +
  geom_density(alpha = 0.5, linewidth = 0.8) + # CHANGED: size = 0.8 -> linewidth = 0.8
  facet_wrap(~ parameter_name, scales = "free", ncol = 2) +
  scale_fill_manual(values = my_colors) +
  scale_color_manual(values = my_colors) +
  labs(
    title = "Posterior vs. Prior Distributions for R Matrix Elements",
    x = "Value",
    y = "Density",
    fill = "Distribution",
    color = "Distribution"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom") +
  # Add vertical lines for true R values (only for simulation studies)
  geom_vline(data = true_R_values_df, aes(xintercept = true_value),
             linetype = "dashed", color = "darkgreen", linewidth = 0.8) # CHANGED: size = 0.8 -> linewidth = 0.8

```

##################################################################################
Simulate X data - R[1,2] = 0.25 and [2,1] = 0.25
```{r}
n_traits <-2
true_a_hat <- c(1,5) #Phylogenetic means for 2 traits
#a <- t(t(t(ones)%*%solve(C)%*%ones)%*%(t(ones)%*%solve(C)%*%X))
#Rearranged to solve for X given a and C
ones<-rep(1,N)
# Example 1: Independent evolution for each trait (covariance = 0)
R_true <- matrix(c(0.3,0.25, #Known R matrix
              0.25,0.5),
             nrow=n_traits, byrow=TRUE)

R_true
V <- kronecker(R_true,C) #Expected variance–covariance matrices for the values for all traits at all tips given ML
mu_sp <- c(rep(true_a_hat[1],N),rep(true_a_hat[2],N))

x_true<-mvrnorm(n=1,mu=mu_sp,Sigma=V) #Simulate X values for both traits
x_true <- matrix(x_true, nrow = N, ncol = n_traits, byrow = FALSE) #Structure so N*r - species by traits
x_error_sd <- 0.01 # Assumed SD of measurement error for x

x_obs <- x_true + rnorm(N*n_traits, 0, x_error_sd)

cat("First 5 rows of Simulated X (Species x Traits):\n")
print(head(x_obs, 5))

a_hat_prior<-colMeans(x_obs)

cat("a_hat_prior:\n")
print(a_hat_prior)

sigma_R_prior_sd <-0.5
```

Setup for mvBlouchBM analysis
```{r}
dat <- list(
  N = N,
  n_traits = n_traits,
  x_obs = as.matrix(x_obs),
  x_error = matrix(rep(x_error_sd,N*n_traits),nrow=N,ncol=n_traits,byrow=FALSE),
  C = C,
  a_hat_prior = a_hat_prior,
  sigma_R_prior_sd = sigma_R_prior_sd
)

print("Stan data list 'dat' created with correctly simulated x_obs")
print("True parameters used:")
print(paste("a_hat:", true_a_hat))
print(paste("R_matrix:", R_true))
print(paste("x_true:", head(x_true)))
print(paste("x_error_sd:", x_error_sd))

```

Prior for Sigma_R
```{r}
mypal <- ggsci::pal_npg("nrc", alpha = 0.4)(2)
mypal[2]<-palette()[1]

# Simulate sigma_R prior values
sigma_R_prior_samples <- abs(rnorm(10000, 0, sigma_R_prior_sd)) # 10,000 samples from half-normal(0,1)
sigma_R_prior_df <- data.frame(value = sigma_R_prior_samples)

ggplot(sigma_R_prior_df, aes(x = value)) +
  geom_density(fill = mypal[2], alpha = 0.2)+
  labs(
    title = "Prior Distribution for sigma_R",
    x = "sigma_R Value",
    y = "Density"
  ) +
  theme_bw()+
  theme(
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank())

```


Two chains
```{r}
setwd('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/')
rstan::stanc('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/mvBlouchBM.stan')
stan_file<-"mvBlouchBM.stan"

stan_model<-rstan::stan_model(file=stan_file) # Compile the Stan model (this takes time the first time)

# Specify the number of chains
n_chains <- 2 

stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    chains = n_chains,             # Use the specified number of chains
    cores = min(n_chains, parallel::detectCores()), # Use available cores up to n_chains
    iter = 2000                  # Keep iterations (or increase if needed)
    #control = list(adapt_delta = 0.8) # Keep control parameters
    )

# You now have results from 2 chains in stan_fit
```

# Posteriors
```{r}
print(stan_fit,
      pars = c("a_hat", "R" 
               ), 
      probs = c(0.025, 0.25, 0.5, 0.75, 0.975), # Default quantiles
      digits_summary = 2) # Adjust number of digits if needed

#rstan::traceplot(stan_fit, pars = c("beta","alpha","theta[1]","es","sd_theta[1]","sd_e[1]"))

post<-rstan::extract(stan_fit)
```

Plotting posterior vs prior for R Matrix
```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(tidybayes) # For spread_draws, gather_draws, median_qi

# Assuming stan_fit is your fitted Stan model object from the previous run

# Extract posterior samples for R directly
# The `gather_draws` function from tidybayes is great for this.
# It automatically converts to a long format suitable for ggplot.
R_posterior_long <- stan_fit %>%
  gather_draws(R[i, j]) %>% #i and j are placeholders for variables
  ungroup() %>% # Remove grouping for easier manipulation
  select(-.chain, -.iteration, -.draw) # Remove internal tidybayes columns if not needed

# Rename columns for clarity
R_posterior_long <- R_posterior_long %>%
  rename(trait1 = i, trait2 = j, value = .value) %>%
  mutate(
    parameter_name = paste0("R[", trait1, ",", trait2, "]"),
    type = "Posterior"
  )

# You'll also need the values of `sigma_R` and `Omega` for the prior (if we simulate from them)
# For now, let's focus on R directly.
```

```{r}

# --- 3. Define the function to simulate R from its Prior ---
# This function simulates from the priors on sigma_R (half-normal) and Omega (correlation matrix).
# NOTE: The correlation matrix simulation (Omega_prior) here uses a heuristic
# (cov2cor(tcrossprod(Z))) because `rlkjcorr` is not available in rstan.
# This heuristic produces valid random correlation matrices, but might not
# precisely match the `lkj_corr(2)` prior for Omega as closely as a dedicated LKJ sampler.
# However, it provides a valuable visual comparison.
simulate_R_prior <- function(n_traits, sigma_prior_sd) {
  # 1. Generate a random correlation matrix (Omega_prior)
  # This method generates a random positive definite matrix and then normalizes it.
  Z <- matrix(rnorm(n_traits * n_traits), n_traits, n_traits)
  Omega_prior <- cov2cor(tcrossprod(Z))

  # 2. Simulate sigma_R from a half-normal prior (abs of normal)
  # Your Stan model uses sigma_R ~ normal(0, 1), which for a <lower=0>
  # constraint means it's a half-normal(0,1).
  sigma_R_prior <- abs(rnorm(n_traits, 0, sigma_prior_sd))

  # 3. Construct the R matrix from sigma_R and Omega
  R_mat <- diag(sigma_R_prior) %*% Omega_prior %*% diag(sigma_R_prior)
  return(R_mat)
}

# --- 4. Generate Prior Samples for R ---
n_prior_samples <- 4000 # Number of prior samples to generate for smooth density

R_prior_list <- list()
for (s in 1:n_prior_samples) {
  R_prior_list[[s]] <- simulate_R_prior(
    n_traits = dat$n_traits,      # Using n_traits from your data list
    sigma_prior_sd = sigma_R_prior_sd            #
  )
}

# Convert prior samples to a long format similar to the posterior
# This part is specifically for n_traits = 2. For larger n_traits,
# you'd need a more generic way to flatten each R_mat, e.g., using `as.vector`
# and then recreating indices.
R_prior_long <- bind_rows(lapply(1:n_prior_samples, function(s) {
  R_mat <- R_prior_list[[s]]
  tibble(
    value = c(R_mat[1,1], R_mat[1,2], R_mat[2,1], R_mat[2,2]),
    trait1 = rep(c(1,1,2,2), length.out = length(value)),
    trait2 = rep(c(1,2,1,2), length.out = length(value)),
    sample_id = s
  )
})) %>%
  mutate(
    parameter_name = paste0("R[", trait1, ",", trait2, "]"),
    type = "Prior"
  ) %>%
  select(-sample_id) # Remove sample_id once converted

# --- 5. Combine Posterior and Prior Data for Plotting ---
plot_data_R <- bind_rows(R_posterior_long, R_prior_long)
```

```{r}

# --- 6. Plotting with ggplot2 (Corrected for linewidth) ---
# Define a custom color palette for Prior and Posterior
my_colors <- c("Prior" = "skyblue", "Posterior" = "darkred")

# Order the facets for better presentation (optional: diagonals first, then off-diagonals)
plot_data_R$parameter_name <- factor(plot_data_R$parameter_name,
                                     levels = c("R[1,1]", "R[2,2]", "R[1,2]", "R[2,1]"))

# Create a data frame for true R values to add as vertical lines
true_R_values_df <- data.frame(
  parameter_name = factor(c("R[1,1]", "R[2,2]", "R[1,2]", "R[2,1]"),
                          levels = c("R[1,1]", "R[2,2]", "R[1,2]", "R[2,1]")),
  true_value = c(R_true[1,1], R_true[2,2], R_true[1,2], R_true[2,1])
)


ggplot(plot_data_R, aes(x = value, fill = type, color = type)) +
  geom_density(alpha = 0.5, linewidth = 0.8) + # CHANGED: size = 0.8 -> linewidth = 0.8
  facet_wrap(~ parameter_name, scales = "free", ncol = 2) +
  scale_fill_manual(values = my_colors) +
  scale_color_manual(values = my_colors) +
  labs(
    title = "Posterior vs. Prior Distributions for R Matrix Elements",
    x = "Value",
    y = "Density",
    fill = "Distribution",
    color = "Distribution"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom") +
  # Add vertical lines for true R values (only for simulation studies)
  geom_vline(data = true_R_values_df, aes(xintercept = true_value),
             linetype = "dashed", color = "darkgreen", linewidth = 0.8) # CHANGED: size = 0.8 -> linewidth = 0.8

```

