---
title: "Simulation Example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulation Example}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This is the Simulation Example from Grabowski (in revision). In this example, we will simulate 
data for a model where Y adapts to four different optima that are influenced by the predictor trait X, and each optima has a different scaling relationship with X. Below, data is simulated following the multi-optima adaptive generative model, and then *Blouch* uses the multilevel multi-optima adaptive model with varying effects (varying intercepts and varying slopes) and the non-multilevel version of the same model to estimate the known parameter values. 

## Setup
```{r setup}
rm(list=ls())
library(blouch)
```

*Blouch* uses RStan to implement Stan. The following code enables some compiler optimizations to improve the estimation speed of the model, and is taken from: https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started
```{r optimizations}
#For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores())
#options(mc.cores = 8)
rstan::rstan_options(auto_write = TRUE)

dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars")
if (!file.exists(M)) file.create(M)
arch <- ifelse(R.version$arch == "aarch64", "arm64", "x86_64")
cat(paste("\nCXX14FLAGS += -O3 -mtune=native -arch", arch, "-ftemplate-depth-256"),
    file = M, sep = "\n", append = FALSE)

```


The *Blouch* package includes the primate phylogeny from the 10KTrees Project (Arnold et al. 2010), which is used for various simulations and comes from https://10ktrees.nunn-lab.org/. This is Version 3 of their primate phylogeny with 301 tips. Here we randomly reduce the tip number to 100 for a more manageable tree using functions from the *ape* R package (Paradis et al. 2004)

```{r Make_tree}
########################################################################################################
#Four regimes with one adaptive trait and multiple slopes per optima but single alpha parameter
set.seed(10) #Set sequence of random numbers for replicability
N<-100 #Number of species

phy <- ape::keep.tip(tree.10K,sample(tree.10K$tip.label)[1:N]) 
phy<-ape::multi2di(phy) #Collapse or resolve multichotomies in phylogenetic trees.

l.tree<-max(ape::branching.times(phy)) ## Rescale tree to height 1
phy$edge.length<-phy$edge.length/l.tree 

```

Lets plot the tree with nodes labeled - these will be where we will be placing our regime shifts in the next step. We will use nodes 164, 192, and 104, which results in 4 regimes - the shifts+the root regime.

```{r Explore_nodes}
#Set regimes - manually - 4 regimes
#Locate nodes
plot(phy,no.margin=TRUE,edge.width=2,cex=0.7)
ape::nodelabels(frame="none",adj=c(1.1,-0.4))
ape::tiplabels()

```

############################################################################################################
## Combine data and tree and paint regimes on tree.
Next we will use the *treeplyr* package (Uyeda and Harmon, 2014) make.treedata function to combine the data and tree based on the taxa names. See https://github.com/uyedaj/treeplyr for more on this package. This step is basically to make a dummy trdata object containing the tree and a blank "dat" dataset object.

Then we will place the regime shifts on the tree that were identified earlier using *Blouch's* set.converge.regimes R function. This function produces a plot of the tree with the colored regimes. In addition,  we will manually plot the tree with the shifts colored to make sure we have done everything correctly.

```{r Set_regimes}

trdata<-data.frame(phy$tip.label)
trdata<-treeplyr::make.treedata(phy,trdata)

shifts<-c(164,192,104) #Location of nodes with regime shifts #100 species
trdata<-set.converge.regimes(trdata,shifts)


#Check if code worked
shifts.total<-c(trdata$dat$regimes,trdata$phy$node.label)
edge.regimes <- factor(shifts.total[trdata$phy$edge[,2]])

reg.colors<-ggsci::pal_npg(palette=c("nrc"),alpha=1)(4)

print(reg.colors)
plot(trdata$phy,edge.color = reg.colors[edge.regimes], edge.width = 1,show.tip.label=FALSE)

reg_tips<-trdata$dat$regimes
reg_tips<-as.numeric(as.factor(reg_tips))

```

############################################################################################################
## Get info on phylogeny
Next we will build a regimes object that will include both internal node and tip regimes, and use *Blouch's* lineage.constructor R function to trace lineages from the tips to the root and determine the regime at each node - this R function is built into *Blouch* and it uses it internally given an empirical dataset, but here we use the function as part of our data simulation.

```{r Make_regime_data}

regimes_internal <-trdata$phy$node.label #Get internal regimes at nodes
regimes_tip <- trdata$dat$regimes #Get regimes at tips
regimes <- concat.factor(regimes_tip, regimes_internal) #Combine these into a list
anc_maps<-"regimes" #Type of regime placement - currently only at nodes
lineages <- lapply(1:N, function(e) lineage.constructor(trdata$phy, e, anc_maps, regimes)) #Trace lineage from tips (n) to root and determine regimes of each node or branch

```

## Set true/known parameter values
Next we set our true/known parameter values. These are for the half-life (hl), and stationary variance (vy), which in our simulation we translate to $\alpha$ (a) and $\sigma^2_y$ (sigma2_y). We set the ancestral value at the root (vX0) to 0, and the instantaneous variance of the BM process (Sxx) to  to 10.

```{r Simulate_data}
#########################
hl<-0.1 #Half life
a<-log(2)/hl #hl expressed as alpha parameter
vy<-0.01 #Stationary Variance
sigma2_y<-vy*(2*(log(2)/hl)); #Vy expressed as random fluctuations of Y

vX0<-0 #Ancestral value at root
sigma2_x<-matrix(1,1,1) #Variance of BM Process

```

## Simulate X data
We first simulate the X data following a Brownian-Motion Process using the fastBM function from the phytools package (Revell 2011) and the parameter values set above. We then plot the values using the phenogram function from the same package to make sure things look as they should.

```{r}
X<-phytools::fastBM(phy,a=vX0,sig2=sigma2_x[1,1],internal=FALSE) #Simulate X BM variable on tree, with BM scaling 10
names(X)<-phy$tip.label
phytools::phenogram(phy,X,spread.labels=TRUE,spread.cost=c(1,0)) #Plot X data

```

## Simulate Y data
Next we need to simulate the Y data - we are using four different optima (intercepts) with four different slopes. We use the R function weight.matrix, which *Blouch* includes to produce the optima_matrix object, which has the weighting for each lineage based on the amount of time spent in each regime (see Hansen 1997 for derivation). This is followed by using the R function calc_adaptive_dmX from *Blouch*, which calculates the design matrix where the observed predictor X variables for each species are multiplied by the the phylogenetic correction factor, following Hansen et al. (2008), and these values are stored in the object pred_X.

We set values for our optima/intercepts (optima) and slopes (beta), and then use a linear model to construct a deterministic relationship between our set parameter values and mu, a vector of mean values for each species in our analysis. 

```{r}
optima_matrix<-weight.matrix(trdata$phy, a, lineages) #Calculate optima/intercepts matrix
pred_X<-calc_adaptive_dmX(phy,a,X) #Calculate design matrix

optima<-c(1,2,3,4) #Simulated optima/intercepts
beta<-c(0.75,0.5,0.35,0.25) #Simulated slopes

mu<-matrix(NA,N,1)
for(i in 1:N){ #Generative function to produce average Y values for each combination of optima/intercepts and slopes following Blouch approach
  mu[i] = optima_matrix[i,]%*%optima+beta[reg_tips[i]]%*%pred_X[i]
}

```

## Calculating V
From there we will construct a variance/covariance matrix (V) based on our previously set parameter values and the  *Blouch* R function calc_adaptive_V, following Hansen et al. (2008). Finally we sill simulate Y values based on our mean vector mu and our covariance matrix V.

```{r}
n_reg<-length(unique(regimes)) #Count number of regimes
Z_adaptive<-1 #Number of adaptive X traits
V<-calc_adaptive_V(phy,a, sigma2_y,  beta,  sigma2_x, Z_adaptive) #Calculate V based on set values
Y<-MASS::mvrnorm(n=1,mu,V) #Simulate Y variables centered on mu with covariariance matrix V 
```

Let's make a simple plot of data, and look at a simple ordinary least squares regression of Y on X. The intercept and slope values will give us an idea of how to center our priors below.

```{r}
df<-data.frame(Y=Y,X=X)

ggplot2::ggplot(data=df,ggplot2::aes(x=X,y=Y))+
  ggplot2::geom_point()
summary(lm(Y~X,df))

```


## Simulating measurement error
Next we will simulate measurement error - we will use a standard deviation of measurement error of 0.01, which we will provide to *Blouch* as a vector (X_error and Y_error), and use the rnorm function to add error to our X and Y variables. In other words, we are telling *Blouch* that the estimated error on X and Y is 0.01, and providing it with X and Y variables that are offset by a random amount of error with this standard deviation.

```{r Simulate_ME}
##################################################################################################################
#Simulate errors
Z_X_error<-1 #Number of X traits with error
X_error<-matrix(0.01,nrow=N,ncol=Z_X_error)
X_error<-data.frame(X_error)
Y_error<-rep(0.01,N)
Y_with_error<-Y+rnorm(N,0,0.01) #Add ME to Y
X_with_error<-X+rnorm(N,0,0.01) #Add ME to X

```

## Data setup for *Blouch*

The first line below combines the existing trdata file from make.trdata which has regime info for the tips with the X and Y predictor values and their errors. We will use the helper function blouch.reg.adapt.prep() to setup the dat object for Stan. This function and the other helper functions included with *Blouch* require trdata files, and then the names of the columns that contain Y and (sometimes depending on the model) X data and error data. "Z_adaptive" is the number of predictors, with "regimes" the name of the column where the tip regime data is located. See help info for each function and other articles on github.com for functionality.

```{r Data_setup}
############################################################################################################
#Make trdata file
trdata$dat<-cbind(trdata$dat,data.frame(cbind(Y_with_error,Y_error,X_with_error,X_error)))
dat<-blouch.reg.adapt.prep(trdata,"Y_with_error","Y_error","X_with_error","X_error",Z_adaptive=1,"regimes")

```

## Exploring Priors
Lets check out our simulated data with reasonable values for the priors shown in light grey lines. These are the ".sims" values - the priors are based on the intercept and slope of the OLS regression above, with standard deviations set by visualizing the priors versus the data. See Grabowski (in revision) for more on setting these priors.

```{r Exploring_priors}
############################################################################################################
#Prior Exploration Plot
lm.allometric<-summary(lm(dat$Y_obs~dat$X_obs)) #Calculate regression of Y on X
lm.allometric$coefficients

optima.sims<-rnorm(100,lm.allometric$coefficients[1],1) #Set priors on alpha/
beta.sims<-rnorm(n=100,lm.allometric$coefficients[2],0.25)

df<-data.frame(Y=dat$Y_obs,X=dat$X_obs[,1])
names(df)<-c("Y","X")

slope.plot<-ggplot2::ggplot()+  
  ggplot2::geom_point(data=df,ggplot2::aes(y=Y,x=X,color=regimes_tip))+
  ggplot2::geom_abline(intercept=optima.sims,slope=beta.sims,alpha=0.1)+
  ggplot2::theme_bw()+
  ggplot2::theme(
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank())+
  
  #ggtitle("Prior vs. Posterior for Intercept and Slope")+
  ggplot2::ylab("Y") + ggplot2::xlab("Adaptive Predictor")+
  ggsci::scale_color_npg()

slope.plot

```

## Running models
First we will run the multilevel multi-optima adaptive model with varying effects. This will allow our intercepts (optima) and slopes to vary with the regimes. As a multilevel model, information can be shared across the regimes, which can produce more accurate parameter estimates. Below are the priors used for this simulation. See Grabowski (in revision) for more on setting these priors. To change these values requires you to open the Stan function, in this case blouchOU_reg_adapt_mlm_ve, and manually edit them. Unfortunately there is no way around this at present, but trust me - it will be worth it.

For example, here are the four most important priors for the models below - these values are explored in Grabowski (in revision), and here I show the priors in their standard easy to read format. Remember, always do prior predictive simulations first - in other words, look at distributions of the values and see if they are actually biologically possible - see the exploring priors step above.

```{r, eval=FALSE}
########################################################################################################
#Priors
#hl ~ lognormal(log(0.25),0.75);
#vy ~ exponential(20);
#optima_bar ~ normal(2.88,1);
#beta_bar ~ normal(0.16,0.25);
```

And here are the lines of Stan code for setting these priors - they are written slightly different here but should be readily understandable To change the values to make them appropriate for your own analyses, you just need to change the numbers below. All Stan programs are in the Blouch/inst/stan folder and named according to the model they run. See Table S1 of Grabowski (in revision) for more on the models. Remember, your priors should be based on what you know about the biological processes underlying your research question and prior predictive simulations (see McElreath 2020)


```{r, eval=FALSE}
#Stan Code
target += lognormal_lpdf(hl|log(0.25),0.75);
target += exponential_lpdf(vy|20);
target += normal_lpdf(optima_bar|2.8,11);
target += normal_lpdf(beta_bar|0.16,0.25);

```


Now let's run the multi-level adaptive model with varying effects (blouchOU_reg_adapt_mlm_ve below).

```{r MLM_VE_Model, results='hide'}
########################################################################################################
#Complete Priors
#hl ~ lognormal(log(0.25),0.75);
#vy ~ exponential(20);
#optima_bar ~ normal(2.8,1);
#beta_bar ~ normal(0.16,0.25);
#Rho ~ lkj_corr(4);

fit.reg.adapt.mlm.ve<- rstan::sampling(blouch:::stanmodels$blouchOU_reg_adapt_mlm_ve,data = dat,chains = 2,cores=2,iter =1000)#, control = list(adapt_delta = 0.95))
```

Stan prints out a lot of info, so lets just look at the parameter estimates here and store the posterior distribution for later use.

```{r Plot_results_MLM_VE_Model}
print(fit.reg.adapt.mlm.ve,pars = c("hl","vy","optima_bar","beta_bar","Rho","sigma","optima","beta","beta_e"))
post.mlm.ve<-rstan::extract(fit.reg.adapt.mlm.ve) #Extract posterior distribution 
```
