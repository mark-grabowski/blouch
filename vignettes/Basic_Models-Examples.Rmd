---
title: "Basic_Models-Examples"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic_Models-Examples}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


```{r}
rm(list=ls())
```

```{r setup}
library(blouch)
```


Here I walk you through the basic models of Blouch. By basic I mean either the direct effect, adaptive, or model with a combination of both types of predictors.

##Direct effect model
Blouch implements the model of constrained evolution (Hansen & Bartoszek, 2012) known as the direct effect model, previously implemented in Grabowski et al. (2016), which can be used to test for allometric constraints.

First we will create a phylogeny by randomly sampling from the 10K Trees phylogeny
```{r Create_phylogeny}
########################################################################################################
#Create phylogeny
########################################################################################################
N<-50 #Number of species
set.seed(10) #Set seed to get same random species each time

phy <- ape::keep.tip(tree.10K,sample(tree.10K$tip.label)[1:N]) 
phy<-ape::multi2di(phy)

l.tree<-max(ape::branching.times(phy)) ## rescale tree to height 1
phy$edge.length<-phy$edge.length/l.tree 

tip.label<-phy$tip.label


```

First we will simulate X and Y data using a generative model for the direct effect model. We will use the treeplyr package (Uyeda and Harmon, 2014) make.treedata function to combine the data and tree based on the row names, which has the taxa names. See https://github.com/uyedaj/treeplyr for more on this package.

```{r Direct_effect_model_setup}
########################################################################################################
#Direct Effect Model
########################################################################################################
#Setup parameters
Z<-1 #Number of traits
hl<-0.1 #0.1, 0.25, 0.75 - testing options
a<-log(2)/hl
vy<-0.01 #0.25,0.5 - testing options
sigma2_y<-vy*(2*(log(2)/hl));

vX0<-0
vY0 <- 0

Sxx<-10 #Look at effects

V<-calc_direct_V(phy,sigma2_y,a)
X<-phytools::fastBM(phy,a=vX0,sig2=Sxx,internal=FALSE) #Simulate X BM variable on tree, with scaling 10
phytools::phenogram(phy,X,spread.labels=TRUE,spread.cost=c(1,0)) #Plot X data

alpha<-2 #Intecept
beta<-0.25 #Slope

mu<-alpha+X*beta #Simulate mu for Y
#Simulate direct effect Y trait
Y<-MASS::mvrnorm(n=1,mu,V)

df<-data.frame(Y=Y,X=X)
names(df)<-c("Y","X")

ggplot2::ggplot(data=df,ggplot2::aes(x=X,y=Y))+
  ggplot2::geom_point()
summary(lm(Y~X,df))

X_error<-rep(0.01,N)
Y_error<-rep(0.01,N)
Y_with_error<-Y+rnorm(N,0,0.01)
X_with_error<-X+rnorm(N,0,0.01)

############################################################################################################
#Make trdata file
trait.data<-data.frame(cbind(Y_with_error,Y_error,X_with_error,X_error))
trdata<-treeplyr::make.treedata(phy,trait.data)

```

We will use the helper function blouch.direct.prep() to setup the dat file for Stan. Here the name of the column in trdata$dat that contains the response variable is "Y_with_error", the associated error column name is "Y_error," the direct effect predictor column is namesd "X_with_error", and its associated errors is "X_error".

```{r blouch.direct.prep}
############################################################################################################
#Test Blouch prep code - direct effect model - blouch.direct.prep()
dat<-blouch.direct.prep(trdata,"Y_with_error","Y_error","X_with_error","X_error",Z_direct=1)

```

```{r Run_direct_effect_model , results='hide'}
fit.direct<- rstan::sampling(object = blouch:::stanmodels$blouchOU_direct,data = dat,chains = 1,iter =400,cores=1)
```

```{r Print_DEM_results}
print(fit.direct,pars = c("hl","vy","alpha","beta"))
#plot(rethinking::precis(fit.direct,depth=3,pars = c("hl","vy","alpha","beta"))) #For use with rethinking package
post<-rstan::extract(fit.direct) #Extract posterior distribution

```

```{r}
rm(list=ls())
```

## Adaptive Model
Blouch also implements the model of adaptive evolution introduced by Hansen et al. (2008). Here the response variable evolves according to an Ornstein-Uhlenbeck process towards an optimal state that is modeled as a function of the predictor variable.

First we will create a phylogeny by randomly sampling from the 10K Trees phylogeny
```{r}
########################################################################################################
#Create phylogeny
########################################################################################################
N<-50 #Number of species
set.seed(10) #Set seed to get same random species each time

phy <- ape::keep.tip(tree.10K,sample(tree.10K$tip.label)[1:N]) 
phy<-ape::multi2di(phy)

l.tree<-max(ape::branching.times(phy)) ## rescale tree to height 1
phy$edge.length<-phy$edge.length/l.tree 

tip.label<-phy$tip.label


```

We will now simulate X and Y data using a generative model for the adaptive model
```{r Adaptive_model_setup}
########################################################################################################
#Adaptive Model
########################################################################################################
#Setup parameters
Z_adaptve<-1 #Number of traits
hl<-0.1
a<-log(2)/hl
vy<-0.1 #0.25,0.5 - testing options
sigma2_y<-vy*(2*(log(2)/hl));
vX0<-0
vY0 <- 0
Sxx<-10 #Look at effects

X<-phytools::fastBM(phy,a=vX0,sig2=Sxx,internal=FALSE) #Simulate X BM variable on tree, with scaling 10
phytools::phenogram(phy,X,spread.labels=TRUE,spread.cost=c(1,0)) #Plot X data
sigma2_x<-matrix(1,1,1)

alpha<-2 #Intecept
beta<-0.25 #Slope

dmX<-calc_adaptive_dmX(phy,a,X) #Calculate the design matrix
mu<-alpha+dmX%*%beta #Simulate mu for Y

V<-calc_adaptive_V(phy,a, sigma2_y, beta,  sigma2_x, Z_adaptive)

#Simulate direct effect Y trait
Y<-MASS::mvrnorm(n=1,mu,V)

df<-data.frame(Y=Y,X=X)
names(df)<-c("Y","X")

ggplot2::ggplot(data=df,ggplot2::aes(x=X,y=Y))+
  ggplot2::geom_point()

summary(lm(Y~X,df))

########################################################################################################
#Simulate errors
X_error<-rep(0.01,N)
Y_error<-rep(0.01,N)
Y_with_error<-Y+rnorm(N,0,0.01)
X_with_error<-X+rnorm(N,0,0.01)

############################################################################################################
#Make trdata file
trait.data<-data.frame(cbind(Y_with_error,Y_error,X_with_error,X_error))
trdata<-treeplyr::make.treedata(phy,trait.data)

############################################################################################################

```

We will use the helper function blouch.adapt.prep() to setup the dat file for Stan. Here the names of the  adaptive column is X_with_error, and its associated errors is X_error.
```{r blouch.adapt.prep}
#Test Blouch prep code - adaptive model
dat<-blouch.adapt.prep(trdata,"Y_with_error","Y_error","X_with_error","X_error",Z_adaptive=1)

```

```{r Run_adaptive_model , results='hide'}
fit.adapt<- rstan::sampling(object = blouch:::stanmodels$blouchOU_adapt,data = dat,chains = 1,iter =400,cores=1)
```

Here the results include both the optimal regression, beta, and the evolutionary regression, beta_e, following Hansen et al. (2008)
```{r Print AM_results}
print(fit.adapt,pars = c("hl","vy","alpha","beta","beta_e"))
#plot(rethinking::precis(fit.adapt,depth=2,pars = c("hl","vy","alpha","beta")))
post<-rstan::extract(fit.adapt)

```
```{r}
rm(list=ls())
```

#Direct effect and adaptive models
First we will create a phylogeny by randomly sampling from the 10K Trees phylogeny
```{r}
########################################################################################################
#Create phylogeny
########################################################################################################
N<-50 #Number of species
set.seed(10) #Set seed to get same random species each time

phy <- ape::keep.tip(tree.10K,sample(tree.10K$tip.label)[1:N]) 
phy<-ape::multi2di(phy)

l.tree<-max(ape::branching.times(phy)) ## rescale tree to height 1
phy$edge.length<-phy$edge.length/l.tree 

tip.label<-phy$tip.label


```

Finally we will simulate X and Y data using a generative model for the direct effect and adaptive model. Here we will have 1 direct effect trait, Xd, and one adaptive trait, Xa.

```{r Direct_adapt_model_setup}
############################################################################################################
#Direct effect + Adaptive Model
############################################################################################################
hl<-0.1 #0.1, 0.25, 0.75 - testing options
a<-log(2)/hl
vy<-0.01 #0.25,0.5 - testing options
sigma2_y<-vy*(2*(log(2)/hl));

vX0<-0
vY0 <- 0

Z_direct<-1
Z_adaptive<-1
Z<-Z_direct+Z_adaptive
sigma2_x<-matrix(1,1,1)

Xd<-rnorm(N,0,1)
names(Xd)<-phy$tip.label
phytools::phenogram(phy,Xd,spread.labels=TRUE,spread.cost=c(1,0)) #Plot X data
Xa<-phytools::fastBM(phy,a=vX0,sig2=sigma2_x[1,1],internal=FALSE) #Simulate X BM variable on tree, with scaling 10
phytools::phenogram(phy,Xa,spread.labels=TRUE,spread.cost=c(1,0)) #Plot X data
#sigma2_x<-ratematrix(phy,Xa) #Calculate evolutionary v/cv matrix
Xs<-cbind(Xd,Xa)

alpha<-2 #Intecept
beta<-c(0.35,0.25) #Slopes
dmX<-calc_mixed_dmX(phy,a,Xs,Z_direct,Z_adaptive)
mu<-alpha+dmX%*%beta #Simulate mu for Y

V<-calc_adaptive_V(phy,a, sigma2_y, beta[(Z_direct+1):(Z_adaptive+Z_direct)],  sigma2_x)
Y<-MASS::mvrnorm(n=1,mu,V)

df<-data.frame(Y=Y,X=Xs)

summary(lm(Y~Xs,df))

ggplot2::ggplot(data=df,ggplot2::aes(x=X.Xd,y=Y))+
  ggplot2::geom_point()

summary(lm(Y~X.Xd,df))

ggplot2::ggplot(data=df,ggplot2::aes(x=X.Xa,y=Y))+
  ggplot2::geom_point()

summary(lm(Y~X.Xa,df))

########################################################################################################
#Simulate errors - for use with blouchOU_reg_direct_adaptive_ME
Z_X_error<-2 #Number of X traits with error
X_error<-matrix(0.01,nrow=N,ncol=Z_X_error)
X_error<-data.frame(X_error)
names(X_error)<-c("Xd_error","Xa_error")
Y_error<-rep(0.01,N)
Y_with_error<-Y+rnorm(N,0,0.01)
X_with_error<-apply(Xs,2,function(X){X+rnorm(N,0,0.01)})

############################################################################################################
#Make trdata file
#trdata<-make.treedata(phy,trait.data)
trait.data<-data.frame(cbind(Y_with_error,Y_error,X_with_error,X_error))
trdata<-treeplyr::make.treedata(phy,trait.data)


```

We will use the helper function blouch.direct.adapt.prep() to setup the dat file for Stan. Here the names of the direct effect and adaptive columns are Xd, and Xa and their associated errors, with Z_direct and Z_adaptive th number of direct and adaptive traits, respectively.
```{r blouch.direct.adapt.prep}
############################################################################################################
#Test Blouch prep code - Direct effect + Adaptive Model
dat<-blouch.direct.adapt.prep(trdata,"Y_with_error","Y_error",c("Xd","Xa"),c("Xd_error","Xa_error"),Z_direct=1,Z_adaptive=1)

```

```{r Run_direct_adapt_model , results='hide'}
fit.direct.adapt<- rstan::sampling(object = blouch:::stanmodels$blouchOU_direct_adapt,data = dat,chains = 1,iter =400,cores=1)

```


```{r Pring_DAM_results}
print(fit.direct.adapt,pars = c("hl","vy","alpha","beta"))
#plot(rethinking::precis(fit.direct.adapt,depth=2,pars = c("hl","vy","alpha","beta")))
post<-rstan::extract(fit.direct.adapt)


```

See Simulation Example for how to explore posterior distribution and model comparison as well as prior and posterior predictive checks
