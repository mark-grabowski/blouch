---
title: "Generative mvOUOU Mitov Approach Script - 1reg"
output: html_notebook
editor_options: 
  chunk_output_type: console
---
########################################################################################################################
# Generate OUOU data with known parameter values and then use to test mvBlouchOUOU Mitov stan code
```{r}
rm(list=ls())
library(MASS)
library(rstan)
library(ggplot2)
library(dplyr)
library(tidybayes) # For spread_draws, median_qi
library(tidyr)     # For crossing, pivot_longer
library(ggsci)     # For AAAS colors
library(truncnorm)
library(matrixcalc)
library(phytools)
#library(blouch)

#install.packages("cmdstanr", repos = c('https://stan-dev.r-universe.dev', getOption("repos")))
#install.packages(c("coda","mvtnorm","devtools","loo","dagitty","shape"))
#devtools::install_github("rmcelreath/rethinking")
#remotes::install_github("uyedaj/treeplyr")

#install.packages("expm")
#install.packages("matrixcalc")
library(expm)

tree.10K<-read.tree('/Users/markgrabowski/Documents/Academic/Research/Data Sets/Other Data Sets/Phylogenies/10K Trees Primate Phylogeny/10KPrimateTree.tre')
######################################################################################################################
#source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/root_trace.R')
#source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/sim_mvOU.R')
#source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/set.converge.regimes.redux.R')
#source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/root_trace_redux.R')

######################################################################################################################
#For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores())
#options(mc.cores = 8)
rstan::rstan_options(auto_write = TRUE)

dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars")
if (!file.exists(M)) file.create(M)
arch <- ifelse(R.version$arch == "aarch64", "arm64", "x86_64")
cat(paste("\nCXX14FLAGS += -O3 -mtune=native -arch", arch, "-ftemplate-depth-256"),
    file = M, sep = "\n", append = FALSE)

```

Generate Phylogeny based on subset 10K Primate Phylogeny - using standard ape::phylo object first
```{r}
N<-30 #Number of species
n_traits <- 2
set.seed(10) #Set seed to get same random species each time

phy <- ape::keep.tip(tree.10K,sample(tree.10K$tip.label)[1:N]) 
phy<-ape::multi2di(phy)

l.tree<-max(ape::branching.times(phy)) ## rescale tree to height 1
phy$edge.length<-phy$edge.length/l.tree 

tip.label<-phy$tip.label
plot(phy)
nodelabels(frame = "n", cex = 0.8, col = "blue")
tiplabels(frame = "n", cex = 0.8, col = "blue")
#phytools::phenogram(phy,X,spread.labels=TRUE,spread.cost=c(1,0)) #Plot X data

plot(phy,no.margin=TRUE,edge.width=2,cex=0.7)
ape::nodelabels(frame="none",adj=c(1.1,-0.4))
ape::tiplabels()

#shifts<-c(56) #Location of nodes with regime shifts
#trdata<-data.frame(phy$tip.label)
#trdata<-treeplyr::make.treedata(phy,trdata)
#trdata<-set.converge.regimes.redux(trdata,shifts)

```

# Simulate Data following Mitov approach

True values - using 2 multivariate traits
```{r}
x0_true<-c(2,6) #Ancestral values for two traits
n_regs <- 1 #One_regime

theta_mat<-data.frame(matrix(c( #Theta matrix - for optima traits are evolving towards, one value in each regime
              3,8), nrow = 2, byrow = TRUE))

colnames(theta_mat)<-c("OU")
rownames(theta_mat)<-c("Trait1","Trait2")

H_mat_reg1<-matrix(c(2,0, #H Matrix - 
              0,2), nrow = 2, byrow = TRUE)

H_mats<-list(H_mat_reg1)

sigma_Sigma <- c(0.5,1.0)  # Fixed scales
Omega_Sigma <- matrix(c(1, 0.2,
                        0.2, 1), nrow = 2)

Sigma_reg1 <- diag(sqrt(sigma_Sigma)) %*% Omega_Sigma %*% diag(sqrt(sigma_Sigma))


#Sigma_reg1<-matrix(c(0.5,0,
#              0,1), nrow = 2, byrow = TRUE)

Sigmas<-list(Sigma_reg1)


```


```{r}
# 1. #Get number of nodes of tree - all internal and tips
is.rooted(phy)
n_nodes<-N+Nnode(phy) #Number of tips + Number of internal nodes

#Get root node number
if(is.rooted(phy)){
  root_node_id <-N+1
}

root_node_id

# 2. Get node types (0=root, 1=tip, 2=internal)
node_types <-rep(2,n_nodes) #Default to internal for all nodes
node_types[1:N] <- 1 #Assign tips 1s
node_types[root_node_id] <- 0 #Assign root 0

```

3. Get Parent and Children indices
```{r}

parent_of_node <- rep(0, n_nodes) #Asign all 0s first, equal to number of nodes
#For each child ID, will store the parent of that child, parent_of_node[child_id] = parent_id
children_of_node_list <- vector("list", n_nodes) #Create vector of list equal to the number of nodes - this will store the children of each parent node - given a parent node id, will return all child node ids
#children_of_node_list[[parent_id]] = c(child1_id, child2_id, ...)

for(i in 1:nrow(phy$edge)){ #For all branches - parent to child nodes in order of node numbers -
  parent <- phy$edge[i, 1] #Get parent node
  child <-phy$edge[i,2] #Get child node
  parent_of_node[child] <- parent #For vector of parent ids, for element = number of child, place parent id in it - returns vector with parent ID for each child ID
  children_of_node_list[[parent]] <- c(children_of_node_list[[parent]], child) #For list of child ids, for the parent node, add on all children that come from that parent node - returns list with children IDs for each parent ID - NULL for tips. Only returns immediate children of parent
}

```

4. Grab branch lengths
```{r}

branch_lengths <- rep(0.0, n_nodes)
bl_child_node_idx<-c() #Will save the ids of th child nodes in the order of the branch length vector
for(i in 1:nrow(phy$edge)){
  child_node <- phy$edge[i,2] #Save the current child node
  bl_child_node_idx<-c(bl_child_node_idx,child_node) #Saves the child IDs in order of the original tree
  branch_lengths[child_node] <- phy$edge.length[i] #For the branch length vector, for the current child node index, save the edge length - returns vector with branch lengths in order of child_nodes
}


```

5b. Set ranch Regimes - single regime
```{r}
branch_regime_idx <- rep(1,n_nodes) #Regimes for each branch in order of child node IDs
n_regs <- 1
#Choose node above - using 50 here
#parent_children_nodes<-getDescendants(phy,32) #Get all nodes that are descendent of the parent at position 32 - half the tree

#branch_regime_idx[parent_children_nodes] <- 2 #For each node, set all children from parent 32 to regime 2

#For printing tree with painted branches
edge_regimes_for_plot <- branch_regime_idx[phy$edge[,2]] #For all children, in order of tree branches, set regimes for edges for plot
reg_colors<-ggsci::pal_npg(palette=c("nrc"),alpha=1)(2) #Set colors based on pal_mpg
plot(phy,edge.color = reg_colors[edge_regimes_for_plot], edge.width = 1, cex = 0.2) #Use regime colors based on order of regimes for edges
```


6. Setup pre-order traversal - ensures all nodes are covered and parents are before children
Versus post-order in the analysis
```{r}
# --- 5. Pre-order traversal for simulation --- parents processed before children
#1. Visit the parent node
#2. Visit its children
#Root to tips order
get_pre_order_nodes <- function(tree_edge, N_tips, N_nodes, root_id) {
  pre_order <- integer(0) #Set up blank pre_order integer vector
  queue <- c(root_id) #Start with root, load it in queue
  
  while (length(queue) > 0) { #while length of queue is greater than 0
    current <- queue[1] #place queue position 1 in current
    queue <- queue[-1] #Remove position 1 from current
    pre_order <- c(pre_order, current) #Combine current parent with existing pre_order integer vector
    current_children <- tree_edge[tree_edge[,1] == current, 2] #Find all children that derive from current parent - matches
    queue <- c(queue, current_children) #Place current children into queue - this will make all children be explored, and put them in the pre_order vector
  }
  return(pre_order)
}

pre_order_node_ids <- get_pre_order_nodes(phy$edge, N, phy$Nnode, root_node_id)

```

7. Calculate current node state based on true parameters and parent parameters
```{r}
calc_current_node_state<-function(current_node, parent_node, parent_state, branch_length, regime_id_for_branch, H_mats, Sigmas, theta_mat){ #
  #Definitions
  
  I<-diag(n_traits) 
  Sigma_sq_matrix <- Sigmas[[regime_id_for_branch]] %*% t(Sigmas[[regime_id_for_branch]])
  H_mat <- H_mats[[regime_id_for_branch]]
  thetas <- theta_mat[,regime_id_for_branch]
  
  #1. Calculate expectation at node given specific regime
  omega <- (I - expm(-H_mat * branch_length)) %*% thetas #Mean shift along branch - t_i = branch length
  phi <-  expm(-H_mat * branch_length) #Linear dependency on ancestral state
  E_x <- omega + phi  %*% parent_state #Expectation, given state of parent
  
  #2. Calculate variance at branch give specific regime - Lyapunov Equation into a Linear System
  L <- kronecker(I, H_mat) + kronecker(H_mat,I)
  s <- vec(Sigma_sq_matrix)
  v <- solve(L) %*% s
  V_stationary <- matrix(v,nrow = n_traits) #Stationary/Equlibrium V/CV Matrix
  V_i <- V_stationary - expm(-H_mat * branch_length) %*% V_stationary %*% expm(-t(H_mat) * branch_length) #Remaining variance over branch
  #For short branches, V_stationary - V_stationary, as expm(-H*ti) will be close to the identity matrix - so near 0

  node_X_state <- mvrnorm(n=1, mu = E_x,Sigma = V_i) #Simulate node state based on expectation and variance
  return(node_X_state)
}
  
```

8. Simulation loop for current node state - walk through tree from root to tips
```{r}
node_true_trait_values<-vector("list",n_nodes) #List of trait values for each node of the tree

#pre_order_node_ids - 
for (current_node in pre_order_node_ids){
  if(current_node == root_node_id){
    node_true_trait_values[[current_node]] <- x0_true
    }
  else{
    parent_node <- parent_of_node[current_node]
    parent_state <- node_true_trait_values[[parent_node]]
    branch_length <- branch_lengths[current_node]
    regime_id_for_branch <- branch_regime_idx[current_node]
    current_node_state<-calc_current_node_state(current_node, parent_node, parent_state, branch_length, regime_id_for_branch, H_mats, Sigmas, theta_mat) #All it returns is the X values at each node
    node_true_trait_values[[current_node]] <- current_node_state #Save current node state
  }
}
#node_true_trait_values

```


# Display Simulated Trait values
```{r}
simulated_tip_values<-t(as.matrix(as.data.frame(node_true_trait_values)))[1:N,]
rownames(simulated_tip_values)<-phy$tip.label
colnames(simulated_tip_values)<-c("Trait1","Trait2")

y_error_sd<-0.01
simulated_tip_values<-simulated_tip_values+rnorm(n=N,0,y_error_sd)
```


```{r}
cat("Plotting Phenogram for Trait 1...\n")
phenogram(phy, simulated_tip_values[,1], spread.labels=FALSE, fsize=0.4,
                    main = "Simulated Trait 1 Evolution"
)

```

```{r}
cat("Plotting Phenogram for Trait 2...\n")
phenogram(phy, simulated_tip_values[,2], spread.labels=FALSE, fsize=0.4,
                    main = "Simulated Trait 2 Evolution"
)
```

# Setup for Stan Analysis

1. Calculate post-order traversal - ensures all nodes are covered and children are visit before parents
```{r}
#Left - right - root
stack1 <-root_node_id
stack2 <- integer(0)

while(length(stack1)>0){ # LIFO (Last-In, First-Out) stack; https://www.naukri.com/code360/library/postorder-traversal-of-binary-tree
  current<-tail(stack1,n=1)
  stack1<-stack1[-length(stack1)]
  stack2<-c(current,stack2)
  stack1<-c(stack1,children_of_node_list[[current]])
}

post_order_path_nodes<-stack2


post_order_branch_lengths<-NULL
post_order_regime_idx<-NULL
post_order_node_types<-NULL

post_order_branch_lengths<-branch_lengths[post_order_path_nodes]
post_order_regime_idx<-branch_regime_idx[post_order_path_nodes]
post_order_node_types<-node_types[post_order_path_nodes]

for (current_node in post_order_path_nodes){
    post_order_branch_lengths <- c(post_order_branch_lengths,branch_lengths[current_node])
    post_order_regime_idx <- c(post_order_regime_idx,branch_regime_idx[current_node])
    post_order_node_types <-c(post_order_node_types,node_types[current_node])
  }



```


Setup for mvBlouchOU analysis
```{r}
#parent_of_node - get parents of all nodes
#children_of_node_list - get immediate children of all parents
children_of_node_matrix<-matrix(unlist(children_of_node_list),ncol=2,byrow=TRUE)

dat <- list(
  N = N,
  n_nodes = n_nodes,
  n_traits = n_traits,
  n_regs = n_regs,
  n_post_order_path_nodes = length(post_order_path_nodes), #Number Postorder path nodes
  n_parent_of_nodes = length(parent_of_node),
  #n_children_of_node_matrix = dim(children_of_node_matrix)[1],
  
  y_obs = as.matrix(simulated_tip_values),
  y_error = matrix(rep(y_error_sd,N*n_traits),nrow=N,ncol=n_traits,byrow=FALSE),
  
  post_order_path_nodes = post_order_path_nodes, 
  branch_lengths = branch_lengths,
  branch_regime_idx = branch_regime_idx,
  parent_of_node = parent_of_node,
  node_types = node_types
  #post_order_branch_lengths = post_order_branch_lengths,
  #post_order_regime_idx = post_order_regime_idx,
  #parent_of_node = parent_of_node,
  #post_order_node_types = post_order_node_types
  
  )

# Trait matrix: rows = tips, cols = traits
# Calculate mean and SD for each trait
trait_means <- colMeans(dat$y_obs)
trait_sds   <- apply(dat$y_obs, 2, sd)

# Standardize Y
#dat$y_obs <- scale(dat$y_obs, center = trait_means, scale = trait_sds)

# Original theta values (one per trait)
theta_mat
theta_true <- c(3, 8)




# Standardize theta (element-wise)
theta_std <- (theta_true - trait_means) / trait_sds
x0_std <- (x0_true - trait_means) / trait_sds


```



To visually explore what your priors look like, you can simulate a large number of samples from each prior distribution specified in your Stan model and then plot their densities or histograms.

This helps you:
1.  **Understand the implications of your prior choices**: Are they placing mass where you expect? Are they too broad or too narrow?
2.  **Diagnose potential issues**: For instance, if a scale parameter prior allows for extremely small values, it can lead to numerical instability.


Simplified Model
Below is R code to do this. I'll assume `n_traits = 2` as per your simulation setup, and use standard `ggplot2` for plotting.
```{r}
# Load required packages
library(ggplot2)
library(MASS)
library(mvtnorm)
library(rethinking)  # for rlkjcorr
library(extraDistr)

set.seed(123)

n_sims <- 50000
n_traits <- 2
mypal <- ggsci::pal_npg("nrc", alpha = 0.4)(2)
mypal[2]<-palette()[1]

#True values for reference
#sigma_Sigma <- c(0.5,1.0)  # Fixed scales
#Omega_Sigma <- matrix(c(1, 0.2,
#                        0.2, 1), nrow = 2)


# ------------------
# Simulated "true" values from your setup
true_vals <- list(
  sigma_Sigma = c(sqrt(Sigma_reg1[1,1]),sqrt(Sigma_reg1[2,2])),
  Sigma = Sigma_reg1,
  Omega_Sigma = Omega_Sigma
)

# ------------------
# Sample hierarchical priors (matching Stan)

# Priors for sigma_Sigma
# Sample Omega_Sigma (correlation matrix) using LKJ prior from rethinking
Omega_Sigma_list <- rlkjcorr(n_sims, K = n_traits, eta = 2)


# ------------------

# sigma_Sigma - from a trunctuated normal distribution
#sigma_Sigma <- cbind(rtruncnorm(n_sims , a = 0, mean = 0, sd = 1 ),rtruncnorm(n_sims , a= 0, mean = 0, sd=1))
#sigma_Sigma <- cbind(rlnorm(n=n_sims,log(0.8),0.2),rlnorm(n=n_sims,log(0.8),0.2)) #Mean around true values - 
sigma_Sigma <- cbind(rlnorm(n=n_sims,0,0.25),rlnorm(n=n_sims,0,0.25)) #Mean around true values - 


# Compute full Sigma matrices
Sigma_mats <- lapply(1:n_sims, function(i) {
  D <- diag(sigma_Sigma[i, ])
  D %*% Omega_Sigma_list[i,,] %*% D
})

Sigma_11 <- sapply(Sigma_mats, function(S) S[1, 1])
Sigma_22 <- sapply(Sigma_mats, function(S) S[2, 2])
Sigma_12 <- sapply(Sigma_mats, function(S) S[1, 2])


# ------------------
# Plotting function
plot_prior <- function(samples, true_value, title, xlab = "Value"){ #, xlim) {
  df <- data.frame(value = samples)
  ggplot(df, aes(x = value, fill=mypal[1])) +
  ggplot2::geom_density()+
    geom_vline(xintercept = true_value, color = "red", linewidth = 1) +
    ggtitle(title) +
    xlab(xlab) +
    #xlim(xlim) +
    ggplot2::scale_fill_manual(values=mypal,name="",labels=c("Prior"))+
    theme_minimal()
}

# ------------------
# Plot each prior with true values

p1 <- plot_prior(sigma_Sigma[, 1], true_vals$sigma_Sigma[1], "Prior: sigma_Sigma[1]")#, xlim = c(0,5))
p2 <- plot_prior(sigma_Sigma[, 2], true_vals$sigma_Sigma[2], "Prior: sigma_Sigma[2]")#, xlim = c(0,5))
print(p1); print(p2)

p3 <- plot_prior(Omega_Sigma_list[,1,2], true_vals$Omega_Sigma[1,2], "Prior: Omega_Sigma[1,2]")#, xlim = c(0,5))
p4 <- plot_prior(Omega_Sigma_list[,2,1], true_vals$Omega_Sigma[2,1], "Prior: Omega_Sigma[2,1]")#, xlim = c(0,5))
print(p3); print(p4)


p5  <- plot_prior(Sigma_11, true_vals$Sigma[1, 1], "Prior: Sigma[1,1]")#, xlim = c(0,5))
p6 <- plot_prior(Sigma_12, true_vals$Sigma[1, 2], "Prior: Sigma[1,2]")#, xlim = c(0,5))
p7 <- plot_prior(Sigma_22, true_vals$Sigma[2, 2], "Prior: Sigma[2,2]")#, xlim = c(0,5))
print(p5); print(p6)
print(p7); 


# Display selected plots



```




Below is R code to do this. I'll assume `n_traits = 2` as per your simulation setup, and use standard `ggplot2` for plotting.
```{r}
# Load required packages
library(ggplot2)
library(MASS)
library(mvtnorm)
library(rethinking)  # for rlkjcorr
library(extraDistr)

set.seed(123)

n_sims <- 10000
n_traits <- 2

# ------------------
# Simulated "true" values from your setup
true_vals <- list(
  sigma_P = eigen(H_mats[[1]])$values,  # From Sigma = diag(sigma) %*% Omega %*% diag(sigma)
  sigma_Sigma = sigma_Sigma,
  lambda = c(2, 2),   # Since H = diag(2, 2)
  theta = theta_std, #c(3, 8),
  H = H_mats[[1]],
  Sigma = Sigmas[[1]]
)

# ------------------
# Sample hierarchical priors (matching Stan)

# Priors for sigma_P
sigma_P_mu_log <- rnorm(n_sims, 0, 1)
#sigma_P_sd_log <- rexp(n_sims, 20)
sigma_P_sd_log <- rhnorm(n_sims, sigma = 0.1)
sigma_P <- t(sapply(1:n_sims, function(i) exp(sigma_P_mu_log[i] + sigma_P_sd_log[i] * rnorm(n_traits))))

# Priors for sigma_Sigma
sigma_Sigma_mu_log <- rnorm(n_sims, 0, 1)
#sigma_Sigma_sd_log <- rexp(n_sims, 20)
sigma_Sigma_sd_log <- rhnorm(n_sims, sigma = 0.1)
sigma_Sigma <- t(sapply(1:n_sims, function(i) exp(sigma_Sigma_mu_log[i] + sigma_Sigma_sd_log[i] * rnorm(n_traits))))

# Priors for log_lambdas (lambda = diag(H))
log_lambda_mu <- rnorm(n_sims, 0, 1)
#log_lambda_sd <- rexp(n_sims, 1)
log_lambda_sd <- rhnorm(n_sims, sigma = 0.1)
lambda <- t(sapply(1:n_sims, function(i) exp(log_lambda_mu[i] + log_lambda_sd[i] * rnorm(n_traits))))

# Priors for theta
theta_prior <- rnorm(n_sims, 0, 1)
#theta_mu <- matrix(rnorm(n_sims * n_traits, 4, 2), ncol = n_traits)
#theta_sd <- rexp(n_sims, 1)
#theta <- t(sapply(1:n_sims, function(i) theta_mu[i, ] + theta_sd[i] * rnorm(n_traits)))

# Sample Omega_Sigma (correlation matrix) using LKJ prior from rethinking
Omega_Sigma_list <- rlkjcorr(n_sims, K = n_traits, eta = 2)

# Compute full Sigma matrices
Sigma_mats <- lapply(1:n_sims, function(i) {
  D <- diag(sigma_Sigma[i, ])
  D %*% Omega_Sigma_list[i,,] %*% D
})
Sigma_11 <- sapply(Sigma_mats, function(S) S[1, 1])
Sigma_22 <- sapply(Sigma_mats, function(S) S[2, 2])
Sigma_12 <- sapply(Sigma_mats, function(S) S[1, 2])

# ------------------
# Compute H matrices (H is diagonal matrix of lambda)
H_11 <- lambda[, 1]
H_22 <- lambda[, 2]

# ------------------
# Plotting function
plot_prior <- function(samples, true_value, title, xlab = "Value", xlim) {
  df <- data.frame(value = samples)
  ggplot(df, aes(x = value)) +
    geom_histogram(bins = 100, color = "black", fill = "skyblue") +
    geom_vline(xintercept = true_value, color = "red", linewidth = 1) +
    ggtitle(title) +
    xlab(xlab) +
    xlim(xlim) +
    theme_minimal()
}

# ------------------
# Plot each prior with true values

p1 <- plot_prior(sigma_P[, 1], true_vals$sigma_P[1], "Prior: sigma_P[1]", xlim = c(0,5))
p2 <- plot_prior(sigma_P[, 2], true_vals$sigma_P[2], "Prior: sigma_P[2]", xlim = c(0,5))

p3 <- plot_prior(sigma_Sigma[, 1], true_vals$sigma_Sigma[1], "Prior: sigma_Sigma[1]", xlim = c(0,5))
p4 <- plot_prior(sigma_Sigma[, 2], true_vals$sigma_Sigma[2], "Prior: sigma_Sigma[2]", xlim = c(0,5))

p5 <- plot_prior(lambda[, 1], true_vals$lambda[1], "Prior: lambda[1]", xlim = c(0,5))
p6 <- plot_prior(lambda[, 2], true_vals$lambda[2], "Prior: lambda[2]", xlim = c(0,5))

p7 <- plot_prior(theta_prior, true_vals$theta[1], "Prior: theta[1]", xlim = c(-5,15))
p8 <- plot_prior(theta_prior, true_vals$theta[2], "Prior: theta[2]", xlim = c(-5,15))

p9  <- plot_prior(Sigma_11, true_vals$Sigma[1, 1], "Prior: Sigma[1,1]", xlim = c(0,5))
p10 <- plot_prior(Sigma_12, true_vals$Sigma[1, 2], "Prior: Sigma[1,2]", xlim = c(0,5))
p11 <- plot_prior(Sigma_22, true_vals$Sigma[2, 2], "Prior: Sigma[2,2]", xlim = c(0,5))

# H matrix plots (diagonal only)
p12 <- plot_prior(H_11, true_vals$H[1, 1], "Prior: H[1,1]", xlim = c(-1,5))
p13 <- plot_prior(H_22, true_vals$H[2, 2], "Prior: H[2,2]", xlim = c(-1,5))

# Display selected plots
print(p1); print(p2)
print(p3); print(p4)
print(p5); print(p6)
print(p7); print(p8)
print(p9); print(p10); print(p11)
print(p12); print(p13)

```

===

Compile model
```{r}
setwd('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/')
rstan::stanc('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/mvBlouchOU_mitov_1reg.stan')
stan_file<-"mvBlouchOU_mitov_1reg.stan"

stan_model<-rstan::stan_model(file=stan_file) # Compile the Stan model (this takes time the first time)
```

Testing version
```{r}
setwd('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/')
rstan::stanc('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/mvOU_mitov.stan')
stan_file<-"mvOU_mitov.stan"

stan_model<-rstan::stan_model(file=stan_file) # Compile the Stan model (this takes time the first time)
```

Debug run
```{r}
stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    chains = 1, 
    cores = 1,   
    iter = 500)

    #control = list(max_treedepth=15, adapt_delta=0.85))

```


```{r}
stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    chains = 2, 
    cores = 2,   
    iter = 2000)

    #control = list(max_treedepth=15, adapt_delta=0.85))

```



# Posteriors
```{r}
print(stan_fit,
      #pars = c("H_mats", "L_Omega_P", "sigma_P", "Sigma_mats", "theta_mats","y_true" 
      pars = c("H_mats", "Sigma_mats", 
               #"sigma_Sigma",
               "theta_mats",
               "y_root",
               #"Omega_Sigma",
               #"rho",
               "y_true"
               #"Sigma_eigenvalues",
               #"P_mats[1,1]","P_mats[1,2]","P_mats[2,1]","P_mats[2,2]",
               #"L_Omega_P[1,1]","L_Omega_P[1,2]","L_Omega_P[2,1]","L_Omega_P[2,2]"
               #"L_Omega_Sigma[1,1]","L_Omega_Sigma[1,2]","L_Omega_Sigma[2,1]","L_Omega_Sigma[2,2]"
               #"sigma_P[1]","sigma_P[2]"
      #pars = c("H_mats", "Sigma_mats", "L_Omega_Sigma", "sigma_Sigma","sigma_Sigma_mu","sigma_Sigma_sd","theta_mats","y_true" 

               ), 
      probs = c(0.025, 0.25, 0.5, 0.75, 0.975), # Default quantiles
      digits_summary = 2) # Adjust number of digits if needed

#rstan::traceplot(stan_fit, pars = c("beta","alpha","theta[1]","es","sd_theta[1]","sd_e[1]"))

post<-rstan::extract(stan_fit)
```


```{r}
traceplot(stan_fit, pars = "lp__") #to check if any chain is stuck.

library(bayesplot)

mcmc_pairs(stan_fit,
           #pars = c("H_mats[1,1]", "H_mats[2,2]", "Sigma_mats[1,2]", "L_Omega_Sigma[1,2]","sigma_Sigma[1]","sigma_Sigma[2]","theta_mats[1]","theta_mats[2]", 
          pars = c("Sigma_mats[1,1]", "Sigma_mats[1,2]", "Sigma_mats[2,1]", "Sigma_mats[2,2]",
                   "sigma_Sigma[1]", "sigma_Sigma[2]",
                   "Omega_Sigma[1,1]", "Omega_Sigma[2,1]","Omega_Sigma[1,2]","Omega_Sigma[2,2]",
                    "lp__" # Always include lp__ to see if divergences cluster with low likelihood
                    ),
           diag_fun = "dens", off_diag_fun = "scatter", np = nuts_params(stan_fit))

```

Prior and Posteriors for Sigma
```{r}
# Load required packages
library(ggplot2)
library(MASS)
library(mvtnorm)
library(rethinking)  # for rlkjcorr
library(extraDistr)

set.seed(123)

n_sims <- 500
n_traits <- 2

# ------------------
# Simulated "true" values from your setup
true_vals <- list(
  sigma_Sigma = c(sqrt(0.1), sqrt(0.25)),
  Sigma = matrix(c(0.1, 0, 0, 0.25), 2, 2)
)

# ------------------
# Sample hierarchical priors (matching Stan)

# Priors for sigma_Sigma
# Sample Omega_Sigma (correlation matrix) using LKJ prior from rethinking
Omega_Sigma_list <- rlkjcorr(n_sims, K = n_traits, eta = 2)

# sigma_Sigma - from a trunctuated normal distribution
sigma_Sigma <- cbind(rtruncnorm(n_sims , a = 0, mean = 0, sd = 0.5),rtruncnorm(n_sims, a = 0, mean = 0, sd=1))

#sigma_Sigma <- cbind(rnorm(n_sims , mean = 0, sd = 1),rtruncnorm(n_sims, mean = 0, sd=1))

# Compute full Sigma matrices
Sigma_mats <- lapply(1:n_sims, function(i) {
  D <- diag(sigma_Sigma[i, ])
  D %*% Omega_Sigma_list[i,,] %*% D
})

Sigma_11 <- sapply(Sigma_mats, function(S) S[1, 1])
Sigma_22 <- sapply(Sigma_mats, function(S) S[2, 2])
Sigma_12 <- sapply(Sigma_mats, function(S) S[1, 2])

df<-data.frame(prior = sigma_Sigma[,1],post = post$sigma_Sigma[,1])
#df<-data.frame(prior = sigma_Sigma[,1])
df<-stack(df)

mypal <- ggsci::pal_npg("nrc", alpha = 0.4)(2)
mypal[2]<-palette()[1]

p<-ggplot2::ggplot(df, aes(x = values , fill = ind))+
  ggplot2::geom_density()+
  ggplot2::geom_vline(xintercept = true_vals$sigma_Sigma[1], color = "red", size = 1) +
  ggplot2::theme_bw()+
  ggplot2::theme(
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank())+
  ggplot2::labs(title="",x="sigma_Sigma[1]", y = "Density")+
  ggplot2::scale_fill_manual(values=mypal,name="",labels=c("Posterior","Prior"))


p

df<-data.frame(prior = sigma_Sigma[,2],post = post$sigma_Sigma[,2])
#df<-data.frame(prior = sigma_Sigma[,2])
df<-stack(df)

mypal <- ggsci::pal_npg("nrc", alpha = 0.4)(2)
mypal[2]<-palette()[1]

p<-ggplot2::ggplot(df, aes(x = values , fill = ind))+
  ggplot2::geom_density()+
  ggplot2::geom_vline(xintercept = true_vals$sigma_Sigma[1], color = "red", size = 1) +
  ggplot2::theme_bw()+
  ggplot2::theme(
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank())+
  ggplot2::labs(title="",x="sigma_Sigma[2]", y = "Density")+
  ggplot2::scale_fill_manual(values=mypal,name="",labels=c("Posterior","Prior"))


p

```



```{r}
generate_init <- function(n_traits) {
  list(
    # Non-centered parameterization for sigma_P (shared mu and sd)
    sigma_P_mu_log = 0,                         # scalar
    sigma_P_sd_log = 0.1,                       # scalar
    sigma_P_raw_z = rnorm(n_traits),            # vector[n_traits]

    # Non-centered parameterization for sigma_Sigma (shared mu and sd)
    sigma_Sigma_mu_log = 0,                     # scalar
    sigma_Sigma_sd_log = 0.1,                   # scalar
    sigma_Sigma_raw_z = rnorm(n_traits),        # vector[n_traits]

    # Cholesky factors of correlation matrices
    L_Omega_P_raw = diag(1, n_traits) + 
      matrix(rnorm(n_traits^2, 0, 0.01), n_traits),
    L_Omega_Sigma_raw = diag(1, n_traits) + 
      matrix(rnorm(n_traits^2, 0, 0.01), n_traits),

    # Lambdas: hierarchical non-centered
    log_lambdas_mu = 0,                         # scalar
    log_lambdas_sd = 0.1,                       # scalar
    log_lambdas_raw_z = rnorm(n_traits),        # vector[n_traits]

    # Theta: hierarchical non-centered
    theta_mu = rnorm(n_traits, 0, 1),           # vector[n_traits]
    theta_sd = 0.5,                             # scalar
    theta_raw_z = rnorm(n_traits)               # vector[n_traits]
  )
}
n_chains<-1
init_list <- lapply(1:n_chains, function(i) generate_init(n_traits))

stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    chains = n_chains, # Keep at 1 for faster debugging iterations
    init = init_list,
    cores = 1,   # Keep at 1 core since you're using 1 chain
    iter = 1000, # Keep iterations lower for faster testing
    control = list(max_treedepth=15, adapt_delta=0.99))


```


Debug run with initial values
```{r}
init <- function() {
  list(
    log_lambdas = rep(0, n_traits),
    L_Omega_P = diag(n_traits),
    sigma_P = rep(1, n_traits),
    L_Omega_Sigma = diag(n_traits),
    sigma_Sigma = rep(1, n_traits),
    y_true = dat$y_obs
  )
}

stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    chains = 2, # Keep at 1 for faster debugging iterations
    init = init,
    cores = 2,   # Keep at 1 core since you're using 1 chain
    iter = 1000, # Keep iterations lower for faster testing
    control = list(max_treedepth=15, adapt_delta=0.99))


```

```{r}
library(tidyverse)

set.seed(42)
n_draws <- 10000
n_traits <- 2

# 1. Theta
theta_mu <- rnorm(n_draws * n_traits, mean = 0, sd = 1) %>% matrix(ncol = n_traits)
theta_sd <- rexp(n_draws, 1)
theta_raw_z <- matrix(rnorm(n_draws * n_traits), ncol = n_traits)

theta_samples <- matrix(NA, nrow = n_draws, ncol = n_traits)
for (i in 1:n_traits) {
  theta_samples[, i] <- theta_mu[, i] + theta_raw_z[, i] * theta_sd
}

# 2. Log lambdas
log_lambdas_mu <- rnorm(n_draws, mean = log(2), sd = 0.5)
log_lambdas_sd <- rexp(n_draws, 1)
log_lambdas_raw_z <- matrix(rnorm(n_draws * n_traits), ncol = n_traits)

log_lambdas_samples <- matrix(NA, nrow = n_draws, ncol = n_traits)
for (i in 1:n_traits) {
  log_lambdas_samples[, i] <- log_lambdas_mu + log_lambdas_sd * log_lambdas_raw_z[, i]
}

lambdas_samples <- exp(log_lambdas_samples)

# 3. sigma_P
sigma_P_mu <- rnorm(n_draws, mean = log(2), sd = 0.5)
sigma_P_sd <- rexp(n_draws, 1)
sigma_P_raw_z <- matrix(rnorm(n_draws * n_traits), ncol = n_traits)

sigma_P_samples <- matrix(NA, nrow = n_draws, ncol = n_traits)
for (i in 1:n_traits) {
  sigma_P_samples[, i] <- sigma_P_mu + sigma_P_sd * sigma_P_raw_z[, i]
}

# 4. sigma_Sigma
sigma_Sigma_mu <- rnorm(n_draws, mean = log(2), sd = 0.5)
sigma_Sigma_sd <- rexp(n_draws, 1)
sigma_Sigma_raw_z <- matrix(rnorm(n_draws * n_traits), ncol = n_traits)

sigma_Sigma_samples <- matrix(NA, nrow = n_draws, ncol = n_traits)
for (i in 1:n_traits) {
  sigma_Sigma_samples[, i] <- sigma_Sigma_mu + sigma_Sigma_sd * sigma_Sigma_raw_z[, i]
}

# Wrap results in tibbles for plotting
theta_df <- as_tibble(theta_samples) %>% rename_with(~paste0("theta_", .))
lambdas_df <- as_tibble(lambdas_samples) %>% rename_with(~paste0("lambda_", .))
sigma_P_df <- as_tibble(sigma_P_samples) %>% rename_with(~paste0("sigmaP_", .))
sigma_Sigma_df <- as_tibble(sigma_Sigma_samples) %>% rename_with(~paste0("sigmaSigma_", .))

# Example plots: Theta and lambdas priors
ggplot(pivot_longer(theta_df, everything(), names_to = "param", values_to = "value"),aes(x=value)) +
  geom_histogram(bins = 50, alpha = 0.6, fill = "blue") +
  facet_wrap(~param, scales = "free") +
  ggtitle("Prior draws for Theta (non-centered)")

ggplot(pivot_longer(lambdas_df, everything(), names_to = "param", values_to = "value"),aes(x=value)) +
  geom_histogram(bins = 50, alpha = 0.6, fill = "green") +
  facet_wrap(~param, scales = "free") +
  xl
  ggtitle("Prior draws for Lambdas")

# You can do the same plotting for sigma_P_df and sigma_Sigma_df.

```

