---
title: "Generative mvOUOU Mitov Approach Script - 1reg"
output: html_notebook
editor_options: 
  chunk_output_type: console
---
########################################################################################################################
# Generate OUOU data with known parameter values and then use to test mvBlouchOUOU Mitov stan code
```{r}
rm(list=ls())
library(MASS)
library(rstan)
library(ggplot2)
library(dplyr)
library(tidybayes) # For spread_draws, median_qi
library(tidyr)     # For crossing, pivot_longer
library(ggsci)     # For AAAS colors
library(truncnorm)
library(matrixcalc)
library(phytools)

library(loo) #For model comparison
#library(blouch)

#install.packages("cmdstanr", repos = c('https://stan-dev.r-universe.dev', getOption("repos")))
#install.packages(c("coda","mvtnorm","devtools","loo","dagitty","shape"))
#devtools::install_github("rmcelreath/rethinking")
#remotes::install_github("uyedaj/treeplyr")

#install.packages("expm")
#install.packages("matrixcalc")
library(expm)

tree.10K<-read.tree('/Users/markgrabowski/Documents/Academic/Research/Data Sets/Other Data Sets/Phylogenies/10K Trees Primate Phylogeny/10KPrimateTree.tre')
######################################################################################################################
#source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/root_trace.R')
#source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/sim_mvOU.R')
#source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/set.converge.regimes.redux.R')
#source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/root_trace_redux.R')

######################################################################################################################
#For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores())
#options(mc.cores = 8)
rstan::rstan_options(auto_write = TRUE)

dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars")
if (!file.exists(M)) file.create(M)
arch <- ifelse(R.version$arch == "aarch64", "arm64", "x86_64")
cat(paste("\nCXX14FLAGS += -O3 -mtune=native -arch", arch, "-ftemplate-depth-256"),
    file = M, sep = "\n", append = FALSE)

```

Generate Phylogeny based on subset 10K Primate Phylogeny - using standard ape::phylo object first
```{r}
N<-100 #Number of species
n_traits <- 2
set.seed(10) #Set seed to get same random species each time

phy <- ape::keep.tip(tree.10K,sample(tree.10K$tip.label)[1:N]) 
phy<-ape::multi2di(phy)

l.tree<-max(ape::branching.times(phy)) ## rescale tree to height 1
phy$edge.length<-phy$edge.length/l.tree 

tip.label<-phy$tip.label
plot(phy)
nodelabels(frame = "n", cex = 0.8, col = "blue")
tiplabels(frame = "n", cex = 0.8, col = "blue")
#phytools::phenogram(phy,X,spread.labels=TRUE,spread.cost=c(1,0)) #Plot X data

plot(phy,no.margin=TRUE,edge.width=2,cex=0.7)
ape::nodelabels(frame="none",adj=c(1.1,-0.4))
ape::tiplabels()

#shifts<-c(56) #Location of nodes with regime shifts
#trdata<-data.frame(phy$tip.label)
#trdata<-treeplyr::make.treedata(phy,trdata)
#trdata<-set.converge.regimes.redux(trdata,shifts)

```

# Simulate Data following Mitov approach

True values - using 2 multivariate traits
```{r}
true_y_root<-c(2,6) #Ancestral values for two traits
n_regs <- 1 #One_regime

true_theta_mat<-data.frame(matrix(c( #Theta matrix - for optima traits are evolving towards, one value in each regime
              3,8), nrow = 2, byrow = TRUE))

colnames(true_theta_mat)<-c("OU")
rownames(true_theta_mat)<-c("Trait1","Trait2")

#true_H_mat_reg1<-matrix(c(2,0, #H Matrix - 
              #0,2), nrow = 2, byrow = TRUE)


true_H_mat_reg1<-matrix(c(2,0.5, #H Matrix - 
              0.5,2), nrow = 2, byrow = TRUE)


true_H_mats<-list(true_H_mat_reg1)

true_half_lives <- lapply(true_H_mats, function(H){log(2)/H})

true_sigma_Sigma <- c(0.5,1.0)  # Fixed scales
true_Omega_Sigma <- matrix(c(1, 0.2,
                        0.2, 1), nrow = 2)

true_Sigma_reg1 <- diag(true_sigma_Sigma) %*% true_Omega_Sigma %*% diag(true_sigma_Sigma)


#true_Sigma_reg1<-matrix(c(0.5,0,
#              0,1), nrow = 2, byrow = TRUE)

true_Sigmas<-list(true_Sigma_reg1)


```


```{r}
# 1. #Get number of nodes of tree - all internal and tips
is.rooted(phy)
n_nodes<-N+Nnode(phy) #Number of tips + Number of internal nodes

#Get root node number
if(is.rooted(phy)){
  root_node_id <-N+1
}

root_node_id

# 2. Get node types (0=root, 1=tip, 2=internal)
node_types <-rep(2,n_nodes) #Default to internal for all nodes
node_types[1:N] <- 1 #Assign tips 1s
node_types[root_node_id] <- 0 #Assign root 0

```

3. Get Parent and Children indices
```{r}

parent_of_node <- rep(0, n_nodes) #Asign all 0s first, equal to number of nodes
#For each child ID, will store the parent of that child, parent_of_node[child_id] = parent_id
children_of_node_list <- vector("list", n_nodes) #Create vector of list equal to the number of nodes - this will store the children of each parent node - given a parent node id, will return all child node ids
#children_of_node_list[[parent_id]] = c(child1_id, child2_id, ...)

for(i in 1:nrow(phy$edge)){ #For all branches - parent to child nodes in order of node numbers -
  parent <- phy$edge[i, 1] #Get parent node
  child <-phy$edge[i,2] #Get child node
  parent_of_node[child] <- parent #For vector of parent ids, for element = number of child, place parent id in it - returns vector with parent ID for each child ID
  children_of_node_list[[parent]] <- c(children_of_node_list[[parent]], child) #For list of child ids, for the parent node, add on all children that come from that parent node - returns list with children IDs for each parent ID - NULL for tips. Only returns immediate children of parent
}

```

4. Grab branch lengths
```{r}

branch_lengths <- rep(0.0, n_nodes)
bl_child_node_idx<-c() #Will save the ids of th child nodes in the order of the branch length vector
for(i in 1:nrow(phy$edge)){
  child_node <- phy$edge[i,2] #Save the current child node
  bl_child_node_idx<-c(bl_child_node_idx,child_node) #Saves the child IDs in order of the original tree
  branch_lengths[child_node] <- phy$edge.length[i] #For the branch length vector, for the current child node index, save the edge length - returns vector with branch lengths in order of child_nodes
}


```

5b. Set ranch Regimes - single regime
```{r}
branch_regime_idx <- rep(1,n_nodes) #Regimes for each branch in order of child node IDs
n_regs <- 1
#Choose node above - using 50 here
#parent_children_nodes<-getDescendants(phy,32) #Get all nodes that are descendent of the parent at position 32 - half the tree

#branch_regime_idx[parent_children_nodes] <- 2 #For each node, set all children from parent 32 to regime 2

#For printing tree with painted branches
edge_regimes_for_plot <- branch_regime_idx[phy$edge[,2]] #For all children, in order of tree branches, set regimes for edges for plot
reg_colors<-ggsci::pal_npg(palette=c("nrc"),alpha=1)(2) #Set colors based on pal_mpg
plot(phy,edge.color = reg_colors[edge_regimes_for_plot], edge.width = 1, cex = 0.2) #Use regime colors based on order of regimes for edges
```


6. Setup pre-order traversal - ensures all nodes are covered and parents are before children
Versus post-order in the analysis
```{r}
# --- 5. Pre-order traversal for simulation --- parents processed before children
#1. Visit the parent node
#2. Visit its children
#Root to tips order
get_pre_order_nodes <- function(tree_edge, N_tips, N_nodes, root_id) {
  pre_order <- integer(0) #Set up blank pre_order integer vector
  queue <- c(root_id) #Start with root, load it in queue
  
  while (length(queue) > 0) { #while length of queue is greater than 0
    current <- queue[1] #place queue position 1 in current
    queue <- queue[-1] #Remove position 1 from current
    pre_order <- c(pre_order, current) #Combine current parent with existing pre_order integer vector
    current_children <- tree_edge[tree_edge[,1] == current, 2] #Find all children that derive from current parent - matches
    queue <- c(queue, current_children) #Place current children into queue - this will make all children be explored, and put them in the pre_order vector
  }
  return(pre_order)
}

pre_order_node_ids <- get_pre_order_nodes(phy$edge, N, phy$Nnode, root_node_id)

```

7. Calculate current node state based on true parameters and parent parameters
```{r}
calc_current_node_state<-function(current_node, parent_node, parent_state, branch_length, regime_id_for_branch, true_H_mats, true_Sigmas, true_theta_mat){ #
  #Definitions
  
  I<-diag(n_traits) 
  #Sigma_sq_matrix <- true_Sigmas[[regime_id_for_branch]] %*% t(true_Sigmas[[regime_id_for_branch]])
  Sigma_mat <- true_Sigmas[[regime_id_for_branch]]
  H_mat <- true_H_mats[[regime_id_for_branch]]
  thetas <- true_theta_mat[,regime_id_for_branch]
  
  #1. Calculate expectation at node given specific regime
  omega <- (I - expm(-H_mat * branch_length)) %*% thetas #Mean shift along branch - t_i = branch length
  phi <-  expm(-H_mat * branch_length) #Linear dependency on ancestral state
  E_x <- omega + phi  %*% parent_state #Expectation, given state of parent
  
  #2. Calculate variance at branch give specific regime - Lyapunov Equation into a Linear System
  L <- kronecker(I, H_mat) + kronecker(H_mat,I)
  #s <- vec(Sigma_sq_matrix)
  #v <- solve(L) %*% s
  v <- solve(L, as.vector(Sigma_mat)) 
  V_stationary <- matrix(v,nrow = n_traits) #Stationary/Equlibrium V/CV Matrix
  V_i <- V_stationary - expm(-H_mat * branch_length) %*% V_stationary %*% expm(-t(H_mat) * branch_length) #Remaining variance over branch
  #For short branches, V_stationary - V_stationary, as expm(-H*ti) will be close to the identity matrix - so near 0
  V_i <- 0.5*(V_i + t(V_i)) #Make symmetrical - NEW Additions
  V_i <- V_i + 1e-10 * diag(n_traits) #Add jitter - NEW Additions
  
  node_X_state <- mvrnorm(n=1, mu = E_x,Sigma = V_i) #Simulate node state based on expectation and variance
  return(node_X_state)
}
  
```

8. Simulation loop for current node state - walk through tree from root to tips
```{r}
node_true_trait_values<-vector("list",n_nodes) #List of trait values for each node of the tree

#pre_order_node_ids - 
for (current_node in pre_order_node_ids){
  if(current_node == root_node_id){
    node_true_trait_values[[current_node]] <- true_y_root
    }
  else{
    parent_node <- parent_of_node[current_node]
    parent_state <- node_true_trait_values[[parent_node]]
    branch_length <- branch_lengths[current_node]
    regime_id_for_branch <- branch_regime_idx[current_node]
    current_node_state<-calc_current_node_state(current_node, parent_node, parent_state, branch_length, regime_id_for_branch, true_H_mats, true_Sigmas, true_theta_mat) #All it returns is the X values at each node
    node_true_trait_values[[current_node]] <- current_node_state #Save current node state
  }
}
#node_true_trait_values

```


# Display Simulated Trait values
```{r}
simulated_tip_values<-t(as.matrix(as.data.frame(node_true_trait_values)))[1:N,]
rownames(simulated_tip_values)<-phy$tip.label
colnames(simulated_tip_values)<-c("Trait1","Trait2")

y_error_sd<-0.01

simulated_tip_values <- simulated_tip_values +
  matrix(rnorm(N * n_traits, 0, y_error_sd), nrow = N, ncol = n_traits)

```


```{r}
cat("Plotting Phenogram for Trait 1...\n")
phenogram(phy, simulated_tip_values[,1], spread.labels=FALSE, fsize=0.4,
                    main = "Simulated Trait 1 Evolution"
)

```

```{r}
cat("Plotting Phenogram for Trait 2...\n")
phenogram(phy, simulated_tip_values[,2], spread.labels=FALSE, fsize=0.4,
                    main = "Simulated Trait 2 Evolution"
)
```

#########################################################################################################
# Setup for Stan Analysis
#########################################################################################################

1. Calculate post-order traversal - ensures all nodes are covered and children are visit before parents
```{r}
#Left - right - root
stack1 <-root_node_id
stack2 <- integer(0)

while(length(stack1)>0){ # LIFO (Last-In, First-Out) stack; https://www.naukri.com/code360/library/postorder-traversal-of-binary-tree
  current<-tail(stack1,n=1)
  stack1<-stack1[-length(stack1)]
  stack2<-c(current,stack2)
  stack1<-c(stack1,children_of_node_list[[current]])
}

post_order_path_nodes<-stack2


post_order_branch_lengths<-NULL
post_order_regime_idx<-NULL
post_order_node_types<-NULL

post_order_branch_lengths<-branch_lengths[post_order_path_nodes]
post_order_regime_idx<-branch_regime_idx[post_order_path_nodes]
post_order_node_types<-node_types[post_order_path_nodes]

#for (current_node in post_order_path_nodes){
#    post_order_branch_lengths <- c(post_order_branch_lengths,branch_lengths[current_node])
#    post_order_regime_idx <- c(post_order_regime_idx,branch_regime_idx[current_node])
#    post_order_node_types <-c(post_order_node_types,node_types[current_node])
#  }



```


Setup for mvBlouchOU analysis
```{r}

# Trait matrix: rows = tips, cols = traits
# Calculate mean and SD for each trait
trait_means <- colMeans(simulated_tip_values)
trait_sds   <- apply(simulated_tip_values, 2, sd)

# Standardize Y
simulated_tip_values_scaled <- scale(simulated_tip_values, 
                                     center = trait_means, 
                                     scale = trait_sds)

# 2) Define measurement error as a fraction of raw trait SDs (e.g., 5%)
measurement_fraction <- 0.05
y_error_sd <- measurement_fraction * trait_sds  # vector of length n_traits

# 3) Scale measurement error for standardized traits
# Divide per-trait error by trait SDs
y_error_scaled <- y_error_sd / trait_sds  # this gives a vector of length n_traits

# 4) Repeat error for all N tips to make matrix N x n_traits for Stan
y_error_matrix <- matrix(rep(y_error_scaled, each = N), nrow = N, ncol = length(trait_sds))

# Check results
simulated_tip_values_scaled[1:5, ]   # first 5 rows
y_error_matrix[1:5, ]                # first 5 rows


# Original theta values (one per trait)
true_theta_mat
theta_true <- c(3, 8)


# Standardize theta (element-wise)
theta_std <- (theta_true - trait_means) / trait_sds
y_root_std <- (true_y_root - trait_means) / trait_sds


#parent_of_node - get parents of all nodes
#children_of_node_list - get immediate children of all parents
children_of_node_matrix<-matrix(unlist(children_of_node_list),ncol=2,byrow=TRUE)

dat <- list(
  N = N,
  n_nodes = n_nodes,
  n_traits = n_traits,
  n_regs = n_regs,
  n_post_order_path_nodes = length(post_order_path_nodes), #Number Postorder path nodes
  n_parent_of_nodes = length(parent_of_node),
  y_obs = as.matrix(simulated_tip_values_scaled), #Using scaled data
  y_error = y_error_matrix, #Using scaled data
  
  post_order_path_nodes = post_order_path_nodes, 
  branch_lengths = branch_lengths,
  branch_regime_idx = branch_regime_idx,
  parent_of_node = parent_of_node,
  node_types = node_types,
  trait_means = trait_means, #Scaled data
  trait_sds = trait_sds

  )

```

###########################################################################################################################
Prior Plots
###########################################################################################################################
To visually explore what your priors look like, you can simulate a large number of samples from each prior distribution specified in your Stan model and then plot their densities or histograms.

This helps you:
1.  **Understand the implications of your prior choices**: Are they placing mass where you expect? Are they too broad or too narrow?
2.  **Diagnose potential issues**: For instance, if a scale parameter prior allows for extremely small values, it can lead to numerical instability.


```{r}
build_G<- function(n_traits, i, j, angle){
    G <- diag(n_traits)
    cos_angle <- cos(angle)
    sin_angle <- sin(angle)
    G[i,i] <- cos_angle
    G[i,j] <- -sin_angle
    G[j,i] <- sin_angle
    G[j,j] <- cos_angle
    return (G)
  }

build_Q<-function(n_traits, Givens_angles){ #Iterate through Givens_angles to update Q
    Q <- diag(n_traits); #Start with identity matrix for Q
    pos <- 1;
    for(j in 2:n_traits){
      for(i in 1:(j-1)){
        Q <- Q %*% build_G(n_traits, i, j, Givens_angles[pos]);
        pos <- pos + 1;
      }
    }
    return(Q)
  }

buld_lower_tri_T<-function(n_traits, T_lower_tri){
    T_lt <- diag(n_traits) #Start with identity matrix for Q
    pos <- 1
    for(j in 1:(n_traits-1)){ #Controls columns
      for(i in (j+1):n_traits){ #Controls rows
        T_lt[i,j] <- T_lower_tri[pos]
        pos <- pos + 1
        }
      }
    return (T_lt)
  }

```


Below is R code to do this. I'll assume `n_traits = 2` as per your simulation setup, and use standard `ggplot2` for plotting.
```{r}
# Load required packages
set.seed(123)

n_sims <- 50000
n_traits <- 2
H <- diag(1/trait_sds) %*% true_H_mats[[1]] %*% diag(trait_sds)

# ------------------
# Simulated "true" values from your setup - using the scaled versions
true_vals <- list(
  y_root = (true_y_root - trait_means)/trait_sds,
  #lambda = c(true_H_mats[[1]][1,1],true_H_mats[[1]][1,2]),
  theta = c((true_theta_mat[1,1] - trait_means[1])/trait_sds[1],(true_theta_mat[2,1] - trait_means[2])/trait_sds[2]), 
  H = diag(1/trait_sds) %*% true_H_mats[[1]] %*% diag(trait_sds),
  half_lives = c(log(2)/H[1,1],log(2)/H[2,2]),
  true_sigma_Sigma = true_sigma_Sigma/trait_sds,
  true_Omega_Sigma = true_Omega_Sigma,
  Sigma = diag(1/trait_sds) %*% true_Sigmas[[1]] %*% diag(1/trait_sds)
)

########
#Priors
########
true_theta_mats_sim <-cbind(rnorm(n=n_sims, 0, 1),rnorm(n=n_sims, 0, 1))
y_root_sim <- cbind(rnorm(n=n_sims, 0, 2),rnorm(n=n_sims, 0, 2))

# Calculate H priors
Givens_angles <- runif(n=n_sims,-pi/2,pi/2);
T_lower_tri <- rnorm(n=n_sims,0,0.5);
#lambdas_mats_sim <- cbind(rlnorm(n=n_sims, 0.5, 0.5),rlnorm(n=n_sims, 0.5, 0.5))
half_lives_sim <- cbind(rlnorm(n=n_sims,log(0.5), 0.4),rlnorm(n=n_sims,log(0.5), 0.4)); #median ~0.5 time units, sensible spread
lambdas_mats_sim <- cbind(log(2)/half_lives_sim[,1],log(2)/half_lives_sim[,2])

#e^1 = 2.72
#e^0 = 1

#Constructing Q
Q_list<-list()
for (i in 1:n_sims) {
  Q_list[[i]] <- build_Q(n_traits, Givens_angles[i])
}


#Constructing T
T_lower_tri_list <- list()

for (i in 1:n_sims) {
  T_lower_tri_list[[i]] <- buld_lower_tri_T(n_traits, T_lower_tri[i]) #Lower tri
  diag(T_lower_tri_list[[i]])<-lambdas_mats_sim[i,] #Diagonal o lambdas
}

#/Constructing H = Q * T * t(Q)
true_H_mats_sims <-list()
for (i in 1:n_sims) {
  true_H_mats_sims[[i]] <- Q_list[[i]] %*% T_lower_tri_list[[i]] %*% t(Q_list[[i]]) #Matrix multiplication
  }


H_off_diagonals<-sapply(true_H_mats_sims, function(H){
  c(H[1,2])})
max(H_off_diagonals) #Off diagonals are not 0
min(H_off_diagonals) #Off diagonals are not 0



#Calculate Sigma priors
true_Omega_Sigma_sim <- rlkjcorr(n_sims, K = n_traits, eta = 2) #Bigger eta = more density to identity matrix, no correlation
true_sigma_Sigma_sim <- cbind(rlnorm(n=n_sims,1,0.1),rlnorm(n=n_sims,1,0.1)) #Mean around true values - 
#exp(1) = 2.72 - lognormal distribution


# Compute full Sigma matrices
Sigma_mats_sim <- lapply(1:n_sims, function(i) {
  D <- diag(true_sigma_Sigma_sim[i, ])
  D %*% true_Omega_Sigma_sim[i,,] %*% D
})

Sigma_11 <- sapply(Sigma_mats_sim, function(S) S[1, 1])
Sigma_22 <- sapply(Sigma_mats_sim, function(S) S[2, 2])
Sigma_12 <- sapply(Sigma_mats_sim, function(S) S[1, 2])

H_11 <- sapply(true_H_mats_sims, function(S) S[1, 1])
H_22 <- sapply(true_H_mats_sims, function(S) S[2, 2])
H_12 <- sapply(true_H_mats_sims, function(S) S[1, 2])



# ------------------
# Plotting function
plot_prior <- function(samples, true_value, title, xlab = "Value") {
  df <- data.frame(value = samples)
    ggplot(df, aes(x = value, fill=mypal[1])) +
    geom_density(alpha = 0.5) +
    geom_vline(xintercept = true_value, color = "black", linewidth = 1, alpha = 0.5) +
    ggtitle(title) +
    xlab(xlab) +
    #xlim(xlim) +
    theme_minimal()
}

```

```{r}
mypal <- ggsci::pal_aaas("default", alpha = 1)(3)

# ------------------
# Plot each prior with true values
plot_prior(y_root_sim[,1], true_vals$y_root[1], "Prior: y_root[1]")
plot_prior(y_root_sim[,2], true_vals$y_root[2], "Prior: y_root[2]")

#plot_prior(lambdas_mats_sim[, 1], true_vals$lambda[1], "Prior: lambda[1]")
#plot_prior(lambdas_mats_sim[, 2], true_vals$lambda[2], "Prior: lambda[2]")

plot_prior(half_lives_sim[, 1], true_vals$half_lives[1], "Prior: half_lives[1]")
plot_prior(half_lives_sim[, 2], true_vals$half_lives[2], "Prior: half_lives[2]")

# H matrix plots
plot_prior(H_11, true_vals$H[1, 1], "Prior: H[1,1]")
plot_prior(H_22, true_vals$H[2, 2], "Prior: H[2,2]")
plot_prior(H_12, true_vals$H[1, 2], "Prior: H[2,2]")

plot_prior(true_theta_mats_sim[,1], true_vals$theta[1], "Prior: theta[1]")
plot_prior(true_theta_mats_sim[,2], true_vals$theta[2], "Prior: theta[2]")


plot_prior(true_sigma_Sigma_sim[, 1], true_vals$true_sigma_Sigma[1], "Prior: true_sigma_Sigma[1]")
plot_prior(true_sigma_Sigma_sim[, 2], true_vals$true_sigma_Sigma[2], "Prior: true_sigma_Sigma[2]")

plot_prior(true_Omega_Sigma_sim[,1,2], true_vals$true_Omega_Sigma[1,2], "Prior: true_Omega_Sigma[1,2]")#, xlim = c(0,5))
plot_prior(true_Omega_Sigma_sim[,2,1], true_vals$true_Omega_Sigma[2,1], "Prior: true_Omega_Sigma[2,1]")#, xlim = c(0,5))


plot_prior(Sigma_11, true_vals$Sigma[1, 1], "Prior: Sigma[1,1]")
plot_prior(Sigma_12, true_vals$Sigma[1, 2], "Prior: Sigma[1,2]")
plot_prior(Sigma_22, true_vals$Sigma[2, 2], "Prior: Sigma[2,2]")


```

###########################################################################################################################
Compile model
###########################################################################################################################

```{r}
setwd('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/')
rstan::stanc('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/mvOU_mitov_1reg.stan')
stan_file<-"mvOU_mitov_1reg.stan"

stan_model<-rstan::stan_model(file=stan_file) # Compile the Stan model (this takes time the first time)
```

Original priors
```{r}
setwd('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/')
rstan::stanc('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/mvOU_mitov_1reg_org.stan')
stan_file<-"mvOU_mitov_1reg_org.stan"

stan_model<-rstan::stan_model(file=stan_file) # Compile the Stan model (this takes time the first time)
```


Debug run
```{r}
stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    chains = 1, 
    cores = 1,   
    iter = 500)

    #control = list(max_treedepth=15, adapt_delta=0.85))

```


```{r}
stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    chains = 2, 
    cores = 2,   
    iter = 2000)
#    , control = list(max_treedepth=12))
#, adapt_delta=0.85))

```



# Posteriors
```{r}
print(stan_fit,
      pars = c("H_mats",
               "H_mats_original",
               "lambdas_mats",
               "half_lives",
               "Sigma_mats",
               "Sigma_mats_original",
               "sigma_Sigma",
               "sigma_Sigma_original",
              "Omega_Sigma",
               "theta_mats",
              "theta_mats_original",
               "y_root",
              "y_root_original"
               ,"y_true",
              "y_true_original"
               ), 
      probs = c(0.025, 0.25, 0.5, 0.75, 0.975), # Default quantiles
      digits_summary = 2) # Adjust number of digits if needed

#rstan::traceplot(stan_fit, pars = c("beta","alpha","theta[1]","es","sd_theta[1]","sd_e[1]"))

post<-rstan::extract(stan_fit)
```

Posterior predictive check - compare original y with simulated y
```{r}

y_rep <- rstan::extract(stan_fit, pars="y_rep")$y_rep
bayesplot::ppc_dens_overlay(simulated_tip_values_scaled[,1], y_rep[1:50,,1])

```

```{r}
library(tidybayes)

posterior_yrep <- spread_draws(stan_fit, y_rep[i,k]) %>%
  mutate(trait = paste0("Trait", k))

# Compare observed and replicated distributions
posterior_yrep %>%
  filter(k == 1) %>%
  ggplot(aes(x = y_rep, group = .iteration)) +
  geom_density(alpha = 0.1, color = "blue") +
  geom_density(data = data.frame(y_obs = Trait1),
               aes(x = y_obs), color = "red", linewidth = 1.2) +
  labs(title = "Posterior Predictive Check - Trait 1",
       x = "Value", y = "Density")

```


```{r}
traceplot(stan_fit, pars = "lp__") #to check if any chain is stuck.

library(bayesplot)

mcmc_pairs(stan_fit,
           pars = c("true_H_mats[1,1]", "true_H_mats[2,2]", "Sigma_mats[1,2]", 
                    "true_sigma_Sigma[1]","true_sigma_Sigma[2]",
                    "Sigma_mats[1,1]", "Sigma_mats[1,2]", "Sigma_mats[2,2]",

                    "true_theta_mats[1]","true_theta_mats[2]", 
                   "true_Omega_Sigma[1,1]", "true_Omega_Sigma[2,1]","true_Omega_Sigma[1,2]","true_Omega_Sigma[2,2]",
                    "lp__" # Always include lp__ to see if divergences cluster with low likelihood
                    ),
           diag_fun = "dens", off_diag_fun = "scatter", np = nuts_params(stan_fit))

```

```{r}
library(tidyverse)
library(tidybayes)
library(ggsci)

mypal <- pal_npg("nrc")(2)

# ------------------
# Plotting function
plot_prior_post <- function(df, title, true_val = NULL) {
  p <- ggplot(df, aes(x = value, fill = source, color = source)) +
    geom_density(alpha = 0.4, adjust = 1.2) +
    scale_fill_manual(values = mypal) +
    scale_color_manual(values = mypal) +
    labs(title = title, x = NULL, y = "Density") +
    theme_minimal(base_size = 12) +
    theme(legend.position = "top",
          plot.title = element_text(hjust = 0.5))
  
  if (!is.null(true_val)) {
    p <- p + geom_vline(xintercept = true_val,
                        color = "red", linetype = "dashed", linewidth = 0.8)
  }
  return(p)
}

# ------------------
# Extract posterior draws with tidybayes
post_df <- stan_fit %>% spread_draws(
  `true_theta_mats[1]`, `true_theta_mats[2]`,
  `true_sigma_Sigma[1]`, `true_sigma_Sigma[2]`,
  `true_Omega_Sigma[1,2]`,
  `y_root[1]`, `y_root[2]`,
  `true_H_mats[1,1]`, `true_H_mats[2,2]`, `true_H_mats[1,2]`
)

# ------------------
# Build prior vs posterior dataframes

# Theta
theta1_df <- tibble(
  value = c(rnorm(n_sims, 0, 1), post_df$`true_theta_mats[1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
theta2_df <- tibble(
  value = c(rnorm(n_sims, 0, 1), post_df$`true_theta_mats[2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# y_root
yroot1_df <- tibble(
  value = c(rnorm(n_sims, 0, 2), post_df$`y_root[1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
yroot2_df <- tibble(
  value = c(rnorm(n_sims, 0, 2), post_df$`y_root[2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# true_sigma_Sigma
sigma1_df <- tibble(
  value = c(rlnorm(n_sims, 1.0, 0.5), post_df$`true_sigma_Sigma[1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
sigma2_df <- tibble(
  value = c(rlnorm(n_sims, 1.0, 0.5), post_df$`true_sigma_Sigma[2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# true_Omega_Sigma correlation
omega12_df <- tibble(
  value = c(rethinking::rlkjcorr(n_sims, K = 2, eta = 2)[,1,2],
            post_df$`true_Omega_Sigma[1,2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# H matrix
lambda1_df <- tibble(
  value = c(rlnorm(n_sims, -0.5, 0.5), post_df$`true_H_mats[1,1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
lambda2_df <- tibble(
  value = c(rlnorm(n_sims, -0.5, 0.5), post_df$`true_H_mats[2,2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
hoffdiag_df <- tibble(
  value = c(rnorm(n_sims, 0, 0.5), post_df$`true_H_mats[1,2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# ------------------
# Make plots with true values

# Simulated "true" values from your setup - using the scaled versions
true_vals <- list(
  y_root = (true_y_root - trait_means)/trait_sds,
  lambda = c(true_H_mats[[1]][1,1],true_H_mats[[1]][1,2]),
  theta = c((true_theta_mat[1,1] - trait_means[1])/trait_sds[1],(true_theta_mat[2,1] - trait_means[2])/trait_sds[2]), 
  H = diag(1/trait_sds) %*% true_H_mats[[1]] %*% diag(trait_sds),
  true_sigma_Sigma = true_sigma_Sigma/trait_sds,
  true_Omega_Sigma = true_Omega_Sigma,
  Sigma = diag(1/trait_sds) %*% true_Sigmas[[1]] %*% diag(1/trait_sds)
)


plot_prior_post(theta1_df, "Theta[1]", true_val = true_vals$theta[1])
plot_prior_post(theta2_df, "Theta[2]", true_val = true_vals$theta[2])

plot_prior_post(yroot1_df, "y_root[1]", true_val = true_vals$y_root[1])
p_yroot2 <- plot_prior_post(yroot2_df, "y_root[2]", true_val = true_vals$y_root[2])

p_sigma1 <- plot_prior_post(sigma1_df, "sigma_Sigma[1]", true_val = true_vals$true_sigma_Sigma[1])
p_sigma2 <- plot_prior_post(sigma2_df, "sigma_Sigma[2]", true_val = true_vals$true_sigma_Sigma[2])

p_omega12 <- plot_prior_post(omega12_df, "Omega_Sigma[1,2]", true_val = true_vals$true_Omega_Sigma[1,2])

p_lambda1 <- plot_prior_post(lambda1_df, "H[1,1]", true_val = true_vals$H[1,1])
p_lambda2 <- plot_prior_post(lambda2_df, "H[2,2]", true_val = true_vals$H[2,2])
p_hoffdiag <- plot_prior_post(hoffdiag_df, "H[1,2]", true_val = true_vals$H[1,2])


```

```{r}
# Required packages
library(posterior)   # as_draws_df / as_draws_array helpers
library(bayesplot)   # mcmc_* plotting
library(ggplot2)
library(dplyr)

# If your stan fit is named differently, replace stan_fit below
draws_array <- as_draws_array(stan_fit)   # draws: iterations x chains x parameters
draws_df    <- as_draws_df(stan_fit)      # tidy draws (iter, chain, variables)
draws_mat   <- as_draws_matrix(stan_fit)  # matrix: iterations * chains x vars

# --- TRUE values (from your simulator) ---
# adjust these object names if your environment uses different ones
true_H  <- true_H_mats[[1]]        # matrix n_traits x n_traits for regime 1
true_S  <- true_Sigmas[[1]]        # Sigma (raw units) for regime 1
true_theta <- as.numeric(true_theta_mat[,1])  # vector length n_traits
true_yroot <- as.numeric(true_y_root)         # vector length n_traits

# Convenience: named list of true scalar values matching Stan parameter names used in plots
true_vals <- list(
  "H_mats[1,1]" = true_H[1,1],
  "H_mats[1,2]" = true_H[1,2],
  "H_mats[2,1]" = true_H[2,1],
  "H_mats[2,2]" = true_H[2,2],
  # original-scale Sigma (if Stan reports Sigma_mats_original[...])
  "Sigma_mats_original[1,1]" = true_S[1,1],
  "Sigma_mats_original[1,2]" = true_S[1,2],
  "Sigma_mats_original[2,2]" = true_S[2,2],
  # original-scale theta and root:
  "theta_mats_original[1]" = true_theta[1],
  "theta_mats_original[2]" = true_theta[2],
  "y_root_original[1]" = true_yroot[1],
  "y_root_original[2]" = true_yroot[2]
)

# ---------------------------
# 1) Traceplots + density with true value lines
# ---------------------------
pars_trace <- c("H_mats[1,1]","H_mats[2,2]","H_mats[1,2]","Sigma_mats_original[1,1]",
                "Omega_Sigma[1,2]","theta_mats_original[1]")

# Trace plot (multiple parameters)
p_trace <- mcmc_trace(draws_array, pars = pars_trace)
print(p_trace)

# Density overlays with true vertical lines
p_dens <- mcmc_dens_overlay(draws_array, pars = pars_trace)
# add true value vertical lines
p_dens + 
  geom_vline(data = data.frame(param = names(true_vals), val = unlist(true_vals)),
             aes(xintercept = val),
             linetype = "dashed", color = "red", size = 0.6, inherit.aes = FALSE)

# ---------------------------
# 2) Posterior intervals / areas with true values shown
# ---------------------------
pars_intervals <- c("H_mats[1,1]", "H_mats[1,2]", "H_mats[2,2]",
                    "Sigma_mats_original[1,1]", "Sigma_mats_original[2,2]",
                    "Omega_Sigma[1,2]", "theta_mats_original[1]", "theta_mats_original[2]")

p_area <- mcmc_areas(draws_array, pars = pars_intervals, prob = 0.95) +
  theme_minimal() +
  ggtitle("Posterior intervals (95%) with true values")

# Overlay true values as points on x axis by adding vertical lines per param
# Build df of true vals for the subset of plotted params
tv_plot <- data.frame(param = pars_intervals, val = unlist(true_vals[pars_intervals]))
# Add dashed vertical lines for each true val
for(i in seq_len(nrow(tv_plot))){
  p_area <- p_area + geom_vline(xintercept = tv_plot$val[i], linetype="dashed", color="red", size=0.5)
}
print(p_area)

# ---------------------------
# 3) Pairwise scatter for key tradeoffs and mark true pair as red point
# ---------------------------
pars_pairs <- c("H_mats[1,1]", "Sigma_mats_original[1,1]", "lambdas_mats[1]")
mcmc_pairs(draws_array, pars = pars_pairs,
           off_diag_args = list(size = 1, alpha = 0.3)) +
  ggtitle("Pairs: H vs Sigma vs lambda (posterior)") +
  theme_minimal()
# Note: to overlay the true point, extract posterior draws and add with geom_point:
# compute true vector
true_pair <- data.frame(
  x = true_vals[["H_mats[1,1]"]],
  y = true_vals[["Sigma_mats_original[1,1]"]],
  z = NA
)
# mcmc_pairs returns ggplot object; adding a single 2D point per panel is trickier â€”
# instead use scatter of posterior means to compare or use custom ggplot below for a single pair:
ggplot(data = as.data.frame(draws_mat)[, c("H_mats[1,1]", "Sigma_mats_original[1,1]")],
       aes(x = `H_mats[1,1]`, y = `Sigma_mats_original[1,1]`)) +
  geom_point(alpha = 0.03, size = 0.8) +
  geom_point(data = data.frame(H = true_vals[["H_mats[1,1]"]], S = true_vals[["Sigma_mats_original[1,1]"]]),
             aes(x = H, y = S), color = "red", size = 3) +
  labs(x = "H_mats[1,1]", y = "Sigma_mats_original[1,1]", title = "Posterior cloud with true value (red)")

# ---------------------------
# 4) Posterior predictive check (PPC)
#    If you have posterior predictions for tips (yrep), use ppc functions.
#    If not, you can simulate yrep from posterior samples of parameters.
# ---------------------------

# If your model produced yrep or y_true draws accessible via stan object, use them directly.
# Example: variable 'yrep' with dims draws x N x trait (adjust varname if different)
if("yrep[1,1]" %in% colnames(draws_mat)){
  # extract a subset of yrep for trait1 (first 200 posterior draws)
  idx_yrep <- grep("^yrep\\[", colnames(draws_mat))
  # this part depends on how yrep is named; user may need to adjust
  yrep_mat <- posterior::subset_draws(as_draws_matrix(stan_fit), variable = "yrep")[, , drop = FALSE]
  # Example simple PPC for trait 1 using first 200 draws (user might need to adapt shape)
  ppc_dens_overlay(y = simulated_tip_values_scaled[,1], yrep = yrep_mat[1:200, , 1])
} else {
  message("No 'yrep' variable found in stan_fit. To run PPC, either save yrep in Stan or simulate posterior predictive draws in R.")
  # Quick: simulate posterior predictive for tip 1 using posterior draws of y_true if available
  if("y_true[1,1]" %in% colnames(draws_mat)){
    ytrue_draws <- as.data.frame(draws_mat)[, grep("^y_true\\[", colnames(draws_mat))]
    # pick a tip index (1) and create density overlay
    ytrue_tip1 <- ytrue_draws[, "y_true[1,1]"]
    ppc_dens_overlay(y = simulated_tip_values_scaled[,1], yrep = matrix(ytrue_tip1[1:2000], nrow=200, byrow=TRUE))
  }
}

# ---------------------------
# 5) Numeric comparison table: posterior medians vs true
# ---------------------------
post_summary <- summarise_draws(as_draws_df(stan_fit), c("H_mats[1,1]","H_mats[1,2]","H_mats[2,2]",
                                                       "Sigma_mats_original[1,1]","Sigma_mats_original[1,2]","Sigma_mats_original[2,2]",
                                                       "theta_mats_original[1]","theta_mats_original[2]"),
                               fun = list(median = ~median(.x), sd = ~sd(.x), `2.5%` = ~quantile(.x,0.025), `97.5%` = ~quantile(.x,0.975)))
# add true values
post_summary <- post_summary %>%
  mutate(true = c(true_vals[["H_mats[1,1]"]], true_vals[["H_mats[1,2]"]], true_vals[["H_mats[2,2]"]],
                  true_vals[["Sigma_mats_original[1,1]"]], true_vals[["Sigma_mats_original[1,2]"]], true_vals[["Sigma_mats_original[2,2]"]],
                  true_vals[["theta_mats_original[1]"]], true_vals[["theta_mats_original[2]"]]))
print(post_summary)

# END

```

