---
title: "Generative mvOUOU Mitov Approach Script - 1reg - Testing Code"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

This is the mvOUOU model with only a single regime (i.e. no paiting of regimes on the phylogeny)
########################################################################################################################
# Generate OUOU data with known parameter values and then use to test mvBlouchOUOU Mitov stan code
```{r}
rm(list=ls())
library(MASS)
library(rstan)
library(ggplot2)
library(dplyr)
library(tidybayes) # For spread_draws, median_qi
library(tidyr)     # For crossing, pivot_longer
library(ggsci)     # For AAAS colors
library(truncnorm)
library(matrixcalc)
library(phytools)
library(rethinking)

library(loo) #For model comparison
#library(blouch)

#install.packages("cmdstanr", repos = c('https://stan-dev.r-universe.dev', getOption("repos")))
#install.packages(c("coda","mvtnorm","devtools","loo","dagitty","shape"))
#devtools::install_github("rmcelreath/rethinking")
#remotes::install_github("uyedaj/treeplyr")

#install.packages("expm")
#install.packages("matrixcalc")
library(expm)

tree.10K<-read.tree('/Users/markgrabowski/Documents/Academic/Research/Data Sets/Other Data Sets/Phylogenies/10K Trees Primate Phylogeny/10KPrimateTree.tre')
######################################################################################################################
#source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/root_trace.R')
#source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/sim_mvOU.R')
#source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/set.converge.regimes.redux.R')
#source('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/R/root_trace_redux.R')

######################################################################################################################
#For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores())
#options(mc.cores = 8)
rstan::rstan_options(auto_write = TRUE)

dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars")
if (!file.exists(M)) file.create(M)
arch <- ifelse(R.version$arch == "aarch64", "arm64", "x86_64")
cat(paste("\nCXX14FLAGS += -O3 -mtune=native -arch", arch, "-ftemplate-depth-256"),
    file = M, sep = "\n", append = FALSE)

```

Generate Phylogeny based on subset 10K Primate Phylogeny - using standard ape::phylo object first
```{r}
N<-100 #Number of species
n_traits <- 2
set.seed(10) #Set seed to get same random species each time

phy <- ape::keep.tip(tree.10K,sample(tree.10K$tip.label)[1:N]) 
phy<-ape::multi2di(phy)

l.tree<-max(ape::branching.times(phy)) ## rescale tree to height 1
phy$edge.length<-phy$edge.length/l.tree 

tip.label<-phy$tip.label
plot(phy)
nodelabels(frame = "n", cex = 0.8, col = "blue")
tiplabels(frame = "n", cex = 0.8, col = "blue")
#phytools::phenogram(phy,X,spread.labels=TRUE,spread.cost=c(1,0)) #Plot X data

plot(phy,no.margin=TRUE,edge.width=2,cex=0.7)
ape::nodelabels(frame="none",adj=c(1.1,-0.4))
ape::tiplabels()

#shifts<-c(56) #Location of nodes with regime shifts
#trdata<-data.frame(phy$tip.label)
#trdata<-treeplyr::make.treedata(phy,trdata)
#trdata<-set.converge.regimes.redux(trdata,shifts)

```

# Simulate Data following Mitov approach - single regime
Diagonal H matrix, diagonal Sigma
True values: Root: 2,6; Thetas: 3,8; H: Diagonal, 1.0, 2.0; Sigma: Diagonal: 0.5, 1.0

```{r}
#Ancestral values for two traits
true_y_root<-c(2,6) 
n_regs <- 1 #One_regime

#Theta construction
true_theta_mat<-data.frame(matrix(c( #Theta matrix - for optima traits are evolving towards, one value in each regime
              3,8), nrow = 2, byrow = TRUE))

colnames(true_theta_mat)<-c("OU")
rownames(true_theta_mat)<-c("Trait1","Trait2")

#true_H_mat_reg1<-matrix(c(2,0, #H Matrix - 
              #0,2), nrow = 2, byrow = TRUE)

#H matrix construction
true_H_mat_reg1<-matrix(c(1.0,0,
              0,2.0), nrow = 2, byrow = TRUE)


true_H_mats<-list(true_H_mat_reg1)

true_half_lives <- lapply(true_H_mats, function(H){log(2)/H})

#Sigma construction
true_sigma_Sigma <- c(0.5,1.0)  # Fixed scales
true_Omega_Sigma <- matrix(c(1, 0,
                        0, 1), nrow = 2)

true_Sigma_reg1 <- diag(true_sigma_Sigma) %*% true_Omega_Sigma %*% diag(true_sigma_Sigma)


#true_Sigma_reg1<-matrix(c(0.5,0,
#              0,1), nrow = 2, byrow = TRUE)

true_Sigmas<-list(true_Sigma_reg1)


```


```{r}
# 1. #Get number of nodes of tree - all internal and tips
is.rooted(phy)
n_nodes<-N+Nnode(phy) #Number of tips + Number of internal nodes

#Get root node number
if(is.rooted(phy)){
  root_node_id <-N+1
}

root_node_id

# 2. Get node types (0=root, 1=tip, 2=internal)
node_types <-rep(2,n_nodes) #Default to internal for all nodes
node_types[1:N] <- 1 #Assign tips 1s
node_types[root_node_id] <- 0 #Assign root 0

```

3. Get Parent and Children indices
```{r}

parent_of_node <- rep(0, n_nodes) #Asign all 0s first, equal to number of nodes
#For each child ID, will store the parent of that child, parent_of_node[child_id] = parent_id
children_of_node_list <- vector("list", n_nodes) #Create vector of list equal to the number of nodes - this will store the children of each parent node - given a parent node id, will return all child node ids
#children_of_node_list[[parent_id]] = c(child1_id, child2_id, ...)

for(i in 1:nrow(phy$edge)){ #For all branches - parent to child nodes in order of node numbers -
  parent <- phy$edge[i, 1] #Get parent node
  child <-phy$edge[i,2] #Get child node
  parent_of_node[child] <- parent #For vector of parent ids, for element = number of child, place parent id in it - returns vector with parent ID for each child ID
  children_of_node_list[[parent]] <- c(children_of_node_list[[parent]], child) #For list of child ids, for the parent node, add on all children that come from that parent node - returns list with children IDs for each parent ID - NULL for tips. Only returns immediate children of parent
}

```

4. Grab branch lengths
```{r}

branch_lengths <- rep(0.0, n_nodes)
bl_child_node_idx<-c() #Will save the ids of th child nodes in the order of the branch length vector
for(i in 1:nrow(phy$edge)){
  child_node <- phy$edge[i,2] #Save the current child node
  bl_child_node_idx<-c(bl_child_node_idx,child_node) #Saves the child IDs in order of the original tree
  branch_lengths[child_node] <- phy$edge.length[i] #For the branch length vector, for the current child node index, save the edge length - returns vector with branch lengths in order of child_nodes
}


```

5b. Set ranch Regimes - single regime
```{r}
branch_regime_idx <- rep(1,n_nodes) #Regimes for each branch in order of child node IDs
n_regs <- 1
#Choose node above - using 50 here
#parent_children_nodes<-getDescendants(phy,32) #Get all nodes that are descendent of the parent at position 32 - half the tree

#branch_regime_idx[parent_children_nodes] <- 2 #For each node, set all children from parent 32 to regime 2

#For printing tree with painted branches
edge_regimes_for_plot <- branch_regime_idx[phy$edge[,2]] #For all children, in order of tree branches, set regimes for edges for plot
reg_colors<-ggsci::pal_npg(palette=c("nrc"),alpha=1)(2) #Set colors based on pal_mpg
plot(phy,edge.color = reg_colors[edge_regimes_for_plot], edge.width = 1, cex = 0.2) #Use regime colors based on order of regimes for edges
```


6. Setup pre-order traversal - ensures all nodes are covered and parents are before children
Versus post-order in the analysis
```{r}
# --- 5. Pre-order traversal for simulation --- parents processed before children
#1. Visit the parent node
#2. Visit its children
#Root to tips order
get_pre_order_nodes <- function(tree_edge, N_tips, N_nodes, root_id) {
  pre_order <- integer(0) #Set up blank pre_order integer vector
  queue <- c(root_id) #Start with root, load it in queue
  
  while (length(queue) > 0) { #while length of queue is greater than 0
    current <- queue[1] #place queue position 1 in current
    queue <- queue[-1] #Remove position 1 from current
    pre_order <- c(pre_order, current) #Combine current parent with existing pre_order integer vector
    current_children <- tree_edge[tree_edge[,1] == current, 2] #Find all children that derive from current parent - matches
    queue <- c(queue, current_children) #Place current children into queue - this will make all children be explored, and put them in the pre_order vector
  }
  return(pre_order)
}

pre_order_node_ids <- get_pre_order_nodes(phy$edge, N, phy$Nnode, root_node_id)

```

7. Calculate current node state based on true parameters and parent parameters
```{r}
calc_current_node_state<-function(current_node, parent_node, parent_state, branch_length, regime_id_for_branch, true_H_mats, true_Sigmas, true_theta_mat){ #
  #Definitions
  
  I<-diag(n_traits) 
  #Sigma_sq_matrix <- true_Sigmas[[regime_id_for_branch]] %*% t(true_Sigmas[[regime_id_for_branch]])
  Sigma_mat <- true_Sigmas[[regime_id_for_branch]]
  H_mat <- true_H_mats[[regime_id_for_branch]]
  thetas <- true_theta_mat[,regime_id_for_branch]
  
  #1. Calculate expectation at node given specific regime
  omega <- (I - expm(-H_mat * branch_length)) %*% thetas #Mean shift along branch - t_i = branch length
  phi <-  expm(-H_mat * branch_length) #Linear dependency on ancestral state
  E_x <- omega + phi  %*% parent_state #Expectation, given state of parent
  
  #2. Calculate variance at branch give specific regime - Lyapunov Equation into a Linear System
  L <- kronecker(I, H_mat) + kronecker(H_mat,I)
  #s <- vec(Sigma_sq_matrix)
  #v <- solve(L) %*% s
  v <- solve(L, as.vector(Sigma_mat)) 
  V_stationary <- matrix(v,nrow = n_traits) #Stationary/Equlibrium V/CV Matrix
  V_i <- V_stationary - expm(-H_mat * branch_length) %*% V_stationary %*% expm(-t(H_mat) * branch_length) #Remaining variance over branch
  #For short branches, V_stationary - V_stationary, as expm(-H*ti) will be close to the identity matrix - so near 0
  V_i <- 0.5*(V_i + t(V_i)) #Make symmetrical - NEW Additions
  V_i <- V_i + 1e-10 * diag(n_traits) #Add jitter - NEW Additions
  
  node_X_state <- mvrnorm(n=1, mu = E_x,Sigma = V_i) #Simulate node state based on expectation and variance
  return(node_X_state)
}
  
```

8. Simulation loop for current node state - walk through tree from root to tips
```{r}
node_true_trait_values<-vector("list",n_nodes) #List of trait values for each node of the tree

#pre_order_node_ids - 
for (current_node in pre_order_node_ids){
  if(current_node == root_node_id){
    node_true_trait_values[[current_node]] <- true_y_root
    }
  else{
    parent_node <- parent_of_node[current_node]
    parent_state <- node_true_trait_values[[parent_node]]
    branch_length <- branch_lengths[current_node]
    regime_id_for_branch <- branch_regime_idx[current_node]
    current_node_state<-calc_current_node_state(current_node, parent_node, parent_state, branch_length, regime_id_for_branch, true_H_mats, true_Sigmas, true_theta_mat) #All it returns is the X values at each node
    node_true_trait_values[[current_node]] <- current_node_state #Save current node state
  }
}
#node_true_trait_values

```


# Display Simulated Trait values
```{r}
simulated_tip_values<-t(as.matrix(as.data.frame(node_true_trait_values)))[1:N,]
rownames(simulated_tip_values)<-phy$tip.label
colnames(simulated_tip_values)<-c("Trait1","Trait2")

y_error_sd<-0.01

simulated_tip_values <- simulated_tip_values +
  matrix(rnorm(N * n_traits, 0, y_error_sd), nrow = N, ncol = n_traits)

```


```{r}
cat("Plotting Phenogram for Trait 1...\n")
phenogram(phy, simulated_tip_values[,1], spread.labels=FALSE, fsize=0.4,
                    main = "Simulated Trait 1 Evolution"
)

```

```{r}
cat("Plotting Phenogram for Trait 2...\n")
phenogram(phy, simulated_tip_values[,2], spread.labels=FALSE, fsize=0.4,
                    main = "Simulated Trait 2 Evolution"
)
```

#########################################################################################################
# Setup for Stan Analysis
#########################################################################################################

1. Calculate post-order traversal - ensures all nodes are covered and children are visit before parents
```{r}
#Left - right - root
stack1 <-root_node_id
stack2 <- integer(0)

while(length(stack1)>0){ # LIFO (Last-In, First-Out) stack; https://www.naukri.com/code360/library/postorder-traversal-of-binary-tree
  current<-tail(stack1,n=1)
  stack1<-stack1[-length(stack1)]
  stack2<-c(current,stack2)
  stack1<-c(stack1,children_of_node_list[[current]])
}

post_order_path_nodes<-stack2


post_order_branch_lengths<-NULL
post_order_regime_idx<-NULL
post_order_node_types<-NULL

post_order_branch_lengths<-branch_lengths[post_order_path_nodes]
post_order_regime_idx<-branch_regime_idx[post_order_path_nodes]
post_order_node_types<-node_types[post_order_path_nodes]

#for (current_node in post_order_path_nodes){
#    post_order_branch_lengths <- c(post_order_branch_lengths,branch_lengths[current_node])
#    post_order_regime_idx <- c(post_order_regime_idx,branch_regime_idx[current_node])
#    post_order_node_types <-c(post_order_node_types,node_types[current_node])
#  }



```


Setup for mvBlouchOU analysis
```{r}

# Trait matrix: rows = tips, cols = traits
# Calculate mean and SD for each trait
trait_means <- colMeans(simulated_tip_values)
trait_sds   <- apply(simulated_tip_values, 2, sd)

# Standardize Y
simulated_tip_values_scaled <- scale(simulated_tip_values, 
                                     center = trait_means, 
                                     scale = trait_sds)

# 2) Define measurement error as a fraction of raw trait SDs (e.g., 5%)
measurement_fraction <- 0.05
y_error_sd <- measurement_fraction * trait_sds  # vector of length n_traits

# 3) Scale measurement error for standardized traits
# Divide per-trait error by trait SDs
y_error_scaled <- y_error_sd / trait_sds  # this gives a vector of length n_traits

# 4) Repeat error for all N tips to make matrix N x n_traits for Stan
y_error_matrix <- matrix(rep(y_error_scaled, each = N), nrow = N, ncol = length(trait_sds))

# Check results
simulated_tip_values_scaled[1:5, ]   # first 5 rows
y_error_matrix[1:5, ]                # first 5 rows

#parent_of_node - get parents of all nodes
#children_of_node_list - get immediate children of all parents
children_of_node_matrix<-matrix(unlist(children_of_node_list),ncol=2,byrow=TRUE)

dat <- list(
  N = N,
  n_nodes = n_nodes,
  n_traits = n_traits,
  n_regs = n_regs,
  n_post_order_path_nodes = length(post_order_path_nodes), #Number Postorder path nodes
  n_parent_of_nodes = length(parent_of_node),
  y_obs = as.matrix(simulated_tip_values_scaled), #Using scaled data
  y_error = y_error_matrix, #Using scaled data
  
  post_order_path_nodes = post_order_path_nodes, 
  branch_lengths = branch_lengths,
  branch_regime_idx = branch_regime_idx,
  parent_of_node = parent_of_node,
  node_types = node_types,
  trait_means = trait_means, #Scaled data
  trait_sds = trait_sds

  )

```

###########################################################################################################################
Prior Plots
###########################################################################################################################
To visually explore what your priors look like, you can simulate a large number of samples from each prior distribution specified in your Stan model and then plot their densities or histograms.

This helps you:
1.  **Understand the implications of your prior choices**: Are they placing mass where you expect? Are they too broad or too narrow?
2.  **Diagnose potential issues**: For instance, if a scale parameter prior allows for extremely small values, it can lead to numerical instability.

These prior simulations are using the priors in Stan, but because y was standardized above, need to be back-transformed to norla space to allow comparison with the true values



Building G, Q, and T matrices as in Stan implementation - just helper functions
```{r}
build_G<- function(n_traits, i, j, angle){
    G <- diag(n_traits)
    cos_angle <- cos(angle)
    sin_angle <- sin(angle)
    G[i,i] <- cos_angle
    G[i,j] <- -sin_angle
    G[j,i] <- sin_angle
    G[j,j] <- cos_angle
    return (G)
  }

build_Q<-function(n_traits, Givens_angles){ #Iterate through Givens_angles to update Q
    Q <- diag(n_traits); #Start with identity matrix for Q
    pos <- 1;
    for(j in 2:n_traits){
      for(i in 1:(j-1)){
        Q <- Q %*% build_G(n_traits, i, j, Givens_angles[pos]);
        pos <- pos + 1;
      }
    }
    return(Q)
  }

buld_lower_tri_T<-function(n_traits, T_lower_tri){
    T_lt <- diag(n_traits) #Start with identity matrix for T
    pos <- 1
    for(j in 1:(n_traits-1)){ #Controls columns
      for(i in (j+1):n_traits){ #Controls rows
        T_lt[i,j] <- T_lower_tri[pos]
        pos <- pos + 1
        }
      }
    return (T_lt)
  }

```


Set True Values
```{r}
# Load required packages
set.seed(123)

n_sims <- 50000
n_traits <- 2

# ------------------
# Simulated "true" values from your setup - using the scaled versions
true_vals <- list(
  y_root = true_y_root,
  theta = true_theta_mat,
  H = true_H_mats[[1]],
  half_lives = true_half_lives[[1]],
  sigma_Sigma = true_sigma_Sigma,
  Omega_Sigma = true_Omega_Sigma,
  Sigma = true_Sigmas[[1]]
)

```


########################################################################################################
Set Priors
########################################################################################################

```{r}
########
#Priors
########

#Half-lives
half_lives_sim <- cbind(rlnorm(n=n_sims,log(0.5), 0.4),rlnorm(n=n_sims,log(0.5), 0.4)); #median ~0.5 time units, 

#Thetas
theta_mats_sim_scaled <-cbind(rnorm(n=n_sims, 0, 2.0),rnorm(n=n_sims, 0, 2.0))
theta_mats_sim_org<-sweep(sweep(theta_mats_sim_scaled,2,trait_sds,"*"),2,trait_means,"+")

#Y_roots
y_root_sim_scaled <- cbind(rnorm(n=n_sims,mean(theta_mats_sim_scaled) , 2.0),rnorm(n=n_sims, mean(theta_mats_sim_scaled), 2.0))
y_root_sim_org <-sweep(sweep(y_root_sim_scaled,2,trait_sds,"*"),2,trait_means,"+")


# Calculate H priors
Givens_angles <- runif(n=n_sims,-pi/2,pi/2);
T_lower_tri <- rnorm(n=n_sims,0,0.5);
#lambdas_mats_sim <- cbind(rlnorm(n=n_sims, 0.5, 0.5),rlnorm(n=n_sims, 0.5, 0.5))
#Half lives and lambdas do not change between scaled and unscaled datasets

#Calculating lambdas (diagonal of H)
lambdas_mats_sim <- cbind(log(2)/half_lives_sim[,1],log(2)/half_lives_sim[,2])

#Constructing Q
Q_list<-list()
for (i in 1:n_sims) {
  Q_list[[i]] <- build_Q(n_traits, Givens_angles[i])
}

#Constructing T
T_lower_tri_list <- list()
for (i in 1:n_sims) {
  T_lower_tri_list[[i]] <- buld_lower_tri_T(n_traits, T_lower_tri[i]) #Lower tri
  diag(T_lower_tri_list[[i]])<-lambdas_mats_sim[i,] #Diagonal o lambdas
}

#/Constructing H = Q * T * t(Q)
H_mats_sims_scaled <-list()
for (i in 1:n_sims) {
  H_mats_sims_scaled[[i]] <- Q_list[[i]] %*% T_lower_tri_list[[i]] %*% t(Q_list[[i]]) #Matrix multiplication
  }


H_off_diagonals_scaled<-sapply(H_mats_sims_scaled, function(H){
  c(H[1,2])})
max(H_off_diagonals_scaled) #Off diagonals are not 0
min(H_off_diagonals_scaled) #Off diagonals are not 0


H_mats_sims_org <-list()
D<-diag(trait_sds)
for (i in 1:n_sims) {
  H_mats_sims_org[[i]] <- D %*% H_mats_sims_scaled[[i]] %*% ginv(D)
  }


#Calculate Sigma priors
Omega_Sigma_sim <- rlkjcorr(n_sims, K = n_traits, eta = 2) #Bigger eta = more density to identity matrix, no correlation - no rescaling needed
sigma_Sigma_sim_scaled <- cbind(rlnorm(n=n_sims,1,0.5),rlnorm(n=n_sims,1,0.25)) #Mean around true values - 
#exp(1) = 2.72 - lognormal distribution
sigma_Sigma_sim_org<-sweep(sigma_Sigma_sim_scaled,2,trait_sds,"*")



# Compute full Sigma matrices - on original scale
Sigma_mats_sim_org <- lapply(1:n_sims, function(i) {
  D <- diag(sigma_Sigma_sim_org[i, ])
  D %*% Omega_Sigma_sim[i,,] %*% D
})


H_11 <- sapply(H_mats_sims_org, function(S) S[1, 1])
H_22 <- sapply(H_mats_sims_org, function(S) S[2, 2])
H_12 <- sapply(H_mats_sims_org, function(S) S[1, 2])
H_21 <- sapply(H_mats_sims_org, function(S) S[2, 1])

Sigma_11 <- sapply(Sigma_mats_sim_org, function(S) S[1, 1])
Sigma_22 <- sapply(Sigma_mats_sim_org, function(S) S[2, 2])
Sigma_12 <- sapply(Sigma_mats_sim_org, function(S) S[1, 2])
Sigma_21 <- sapply(Sigma_mats_sim_org, function(S) S[2, 1])

```

```{r}
# ------------------
# Prior Plotting function
plot_prior <- function(samples, true_value, title, xlab = "Value") {
  df <- data.frame(value = samples)
    ggplot(df, aes(x = value, fill=mypal[1])) +
    geom_density(alpha = 0.5) +
    geom_vline(xintercept = true_value, color = "black", linewidth = 1, alpha = 0.5) +
    ggtitle(title) +
    xlab(xlab) +
    #xlim(xlim) +
    theme_minimal()
}

```

```{r}
mypal <- ggsci::pal_aaas("default", alpha = 1)(3)

# ------------------
# Plot each prior with true values
plot_prior(theta_mats_sim_org[,1], t(true_vals$theta)[1], "Prior: theta[1]")
plot_prior(theta_mats_sim_org[,2], t(true_vals$theta)[2], "Prior: theta[2]")

plot_prior(y_root_sim_org[,1], true_vals$y_root[1], "Prior: y_root[1]")
plot_prior(y_root_sim_org[,2], true_vals$y_root[2], "Prior: y_root[2]")

plot_prior(half_lives_sim[, 1], true_vals$half_lives[1,1], "Prior: half_lives[1]")
plot_prior(half_lives_sim[, 2], true_vals$half_lives[2,2], "Prior: half_lives[2]")

# H matrix plots
plot_prior(H_11, true_vals$H[1, 1], "Prior: H[1,1]")
plot_prior(H_22, true_vals$H[2, 2], "Prior: H[2,2]")
plot_prior(H_12, true_vals$H[1, 2], "Prior: H[1,2]")
plot_prior(H_21, true_vals$H[2, 1], "Prior: H[2,1]")

#sigma Sigma
plot_prior(sigma_Sigma_sim_org[, 1], true_vals$sigma_Sigma[1], "Prior: true_sigma_Sigma[1]")
plot_prior(sigma_Sigma_sim_org[, 2], true_vals$sigma_Sigma[2], "Prior: true_sigma_Sigma[2]")

#Omega Sigma
plot_prior(Omega_Sigma_sim[,1,2], true_vals$Omega_Sigma[1,2], "Prior: true_Omega_Sigma[1,2]")#, xlim = c(0,5))

#Sigmas
plot_prior(Sigma_11, true_vals$Sigma[1, 1], "Prior: Sigma[1,1]")
plot_prior(Sigma_22, true_vals$Sigma[2, 2], "Prior: Sigma[2,2]")
plot_prior(Sigma_12, true_vals$Sigma[1, 2], "Prior: Sigma[1,2]")
plot_prior(Sigma_21, true_vals$Sigma[2, 1], "Prior: Sigma[2,2]")


```

###########################################################################################################################
Compile model
###########################################################################################################################

```{r}
setwd('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/')
rstan::stanc('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/mvOU_mitov_1reg.stan')
stan_file<-"mvOU_mitov_1reg.stan"

stan_model<-rstan::stan_model(file=stan_file) # Compile the Stan model (this takes time the first time)
```


Debug run
```{r}
stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    chains = 1, 
    cores = 1,   
    iter = 500)

    #control = list(max_treedepth=15, adapt_delta=0.85))

```

Real run
```{r}
stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    chains = 2, 
    cores = 2,   
    iter = 2000)
#    , control = list(max_treedepth=12))
#, adapt_delta=0.85))

```

# Look at Posteriors
```{r}
print(stan_fit,
      pars = c("H_mats",
               "H_mats_original",
               "half_lives",
               "Sigma_mats",
               "Sigma_mats_original",
               "sigma_Sigma",
               "sigma_Sigma_original",
              "Omega_Sigma",
               "theta_mats",
              "theta_mats_original",
               "y_root",
              "y_root_original"
               ), 
      probs = c(0.025, 0.25, 0.5, 0.75, 0.975), # Default quantiles
      digits_summary = 2) # Adjust number of digits if needed

#rstan::traceplot(stan_fit, pars = c("beta","alpha","theta[1]","es","sd_theta[1]","sd_e[1]"))

post<-rstan::extract(stan_fit)
```

Posterior predictive check - compare original y with simulated y
```{r}
y_rep <- rstan::extract(stan_fit, pars="y_rep")$y_rep
bayesplot::ppc_dens_overlay(simulated_tip_values_scaled[,1], y_rep[1:50,,1])
```

# Pairs plot
```{r}
traceplot(stan_fit, pars = "lp__") #to check if any chain is stuck.

library(bayesplot)

mcmc_pairs(stan_fit,
           pars = c("H_mats_original[1,1]", "H_mats_original[2,2]", "Sigma_mats_original[1,2]", 
                    "sigma_Sigma_original[1]","sigma_Sigma_original[2]",
                    "Sigma_mats_original[1,1]", "Sigma_mats_original[1,2]", "Sigma_mats_original[2,2]",

                    "theta_mats_original[1]","theta_mats_original[2]", 
                   "Omega_Sigma[1,1]", "Omega_Sigma[2,1]","Omega_Sigma[1,2]","Omega_Sigma[2,2]",
                    "lp__" # Always include lp__ to see if divergences cluster with low likelihood
                    ),
           diag_fun = "dens", off_diag_fun = "scatter", np = nuts_params(stan_fit))

```


# Code for plotting posteriors vs. priors
```{r}
library(tidyverse)
library(tidybayes)
library(ggsci)

mypal <- pal_npg("nrc")(2)

# ------------------
# Plotting function
plot_prior_post <- function(df, title, true_val = NULL) {
  p <- ggplot(df, aes(x = value, fill = source, color = source)) +
    geom_density(alpha = 0.4, adjust = 1.2) +
    scale_fill_manual(values = mypal) +
    scale_color_manual(values = mypal) +
    labs(title = title, x = NULL, y = "Density") +
    theme_minimal(base_size = 12) +
    theme(legend.position = "top",
          plot.title = element_text(hjust = 0.5))
  
  if (!is.null(true_val)) {
    p <- p + geom_vline(xintercept = true_val,
                        color = "red", linetype = "dashed", linewidth = 0.8)
  }
  return(p)
}

```

# Extract posterior draws with tidybayes
```{r}
# ------------------
post_df <- stan_fit %>% spread_draws(
  `theta_mats_original[1]`, `theta_mats_original[2]`,
  `sigma_Sigma_original[1]`, `sigma_Sigma_original[2]`,
  `Omega_Sigma[1,2]`,
  `y_root_original[1]`, `y_root_original[2]`,
  `H_mats_original[1,1]`, `H_mats_original[2,2]`, `H_mats_original[1,2]`,`H_mats_original[2,1]`,
  `half_lives[1]`, `half_lives[2]`
)

```
# Build prior vs posterior dataframes
```{r}
# ------------------
#Half lives
#half_lives ~ lognormal(log(0.5), 0.4); // median ~0.5 time units, sensible spread
halflife1_df <- tibble(
  value = c(half_lives_sim[,1], post_df$`half_lives[1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

halflife2_df <- tibble(
  value = c(half_lives_sim[,2], post_df$`half_lives[2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# Theta
theta1_df <- tibble(
  value = c(theta_mats_sim_org[,1], post_df$`theta_mats_original[1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
theta2_df <- tibble(
  value = c(theta_mats_sim_org[,2], post_df$`theta_mats_original[2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# y_root
yroot1_df <- tibble(
  value = c(y_root_sim_org[,1], post_df$`y_root_original[1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

yroot2_df <- tibble(
  value = c(y_root_sim_org[,2], post_df$`y_root_original[2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# sigma_Sigma_original
sigma1_df <- tibble(
  value = c(sigma_Sigma_sim_org[,1], post_df$`sigma_Sigma_original[1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
sigma2_df <- tibble(
  value = c(sigma_Sigma_sim_org[,1], post_df$`sigma_Sigma_original[2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# Omega_Sigma correlation
omega12_df <- tibble(
  value = c(Omega_Sigma_sim[,1,2],
            post_df$`Omega_Sigma[1,2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# H matrix
H11_sims_org <- sapply(H_mats_sims_org, function(mat) {
  mat[1, 1]
})
  
H22_sims_org <- sapply(H_mats_sims_org, function(mat) {
  mat[2, 2]
})
H12_sims_org <- sapply(H_mats_sims_org, function(mat) {
  mat[1, 2]
})
H21_sims_org <- sapply(H_mats_sims_org, function(mat) {
  mat[2, 1]
})
  
H11_df <- tibble(
  value = c(H11_sims_org, post_df$`H_mats_original[1,1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
H22_df <- tibble(
  value = c(H22_sims_org, post_df$`H_mats_original[2,2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

H12_df <- tibble(
  value = c(H12_sims_org, post_df$`H_mats_original[1,2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

H21_df <- tibble(
  value = c(H21_sims_org, post_df$`H_mats_original[2,1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
```


```{r}
# ------------------
# Make plots with true values

#true_vals set above
plot_prior_post(halflife1_df, "Halflife[1]", true_val = true_vals$half_lives[1,1])
plot_prior_post(halflife2_df, "Halflife[2]", true_val = true_vals$half_lives[2,2])

plot_prior_post(theta1_df, "Theta[1]", true_val = true_vals$theta[1,1])
plot_prior_post(theta2_df, "Theta[2]", true_val = true_vals$theta[2,1])

plot_prior_post(yroot1_df, "y_root[1]", true_val = true_vals$y_root[1])
plot_prior_post(yroot2_df, "y_root[2]", true_val = true_vals$y_root[2])

plot_prior_post(sigma1_df, "sigma_Sigma[1]", true_val = true_vals$sigma_Sigma[1])
plot_prior_post(sigma2_df, "sigma_Sigma[2]", true_val = true_vals$sigma_Sigma[2])

plot_prior_post(omega12_df, "Omega_Sigma[1,2]", true_val = true_vals$Omega_Sigma[1,2])

plot_prior_post(H11_df, "H[1,1]", true_val = true_vals$H[1,1])
plot_prior_post(H22_df, "H[2,2]", true_val = true_vals$H[2,2])
plot_prior_post(H12_df, "H[1,2]", true_val = true_vals$H[1,2])
plot_prior_post(H21_df, "H[2,1]", true_val = true_vals$H[2,1])

```

#########################################################################################################################
# User Set H matix options
#########################################################################################################################

# Simulate Data following Mitov approach - single regime
Diagonal H matrix, diagonal Sigma
True values: Root: 2,6; Thetas: 3,8; H: Diagonal, 1.0, 2.0; Sigma: Diagonal: 0.5, 1.0

```{r}
#Ancestral values for two traits
true_y_root<-c(2,6) 
n_regs <- 1 #One_regime

#Theta construction
true_theta_mat<-data.frame(matrix(c( #Theta matrix - for optima traits are evolving towards, one value in each regime
              3,8), nrow = 2, byrow = TRUE))

colnames(true_theta_mat)<-c("OU")
rownames(true_theta_mat)<-c("Trait1","Trait2")

#true_H_mat_reg1<-matrix(c(2,0, #H Matrix - 
              #0,2), nrow = 2, byrow = TRUE)

#H matrix construction - upper triangular is positive - if x2 is positive, pushes x1 towards optimum, if x2 is negative, pushes x1 away from optima - here it is positive - theta - x2, where theta is bigger than x2
true_H_mat_reg1<-matrix(c(1.0,0,
              0,2.0), nrow = 2, byrow = TRUE)


true_H_mats<-list(true_H_mat_reg1)

true_half_lives <- lapply(true_H_mats, function(H){log(2)/H})

#Sigma construction
true_sigma_Sigma <- c(0.5,1.0)  # Fixed scales
true_Omega_Sigma <- matrix(c(1, 0,
                        0, 1), nrow = 2)

true_Sigma_reg1 <- diag(true_sigma_Sigma) %*% true_Omega_Sigma %*% diag(true_sigma_Sigma)


#true_Sigma_reg1<-matrix(c(0.5,0,
#              0,1), nrow = 2, byrow = TRUE)

true_Sigmas<-list(true_Sigma_reg1)


```


```{r}
# 1. #Get number of nodes of tree - all internal and tips
is.rooted(phy)
n_nodes<-N+Nnode(phy) #Number of tips + Number of internal nodes

#Get root node number
if(is.rooted(phy)){
  root_node_id <-N+1
}

root_node_id

# 2. Get node types (0=root, 1=tip, 2=internal)
node_types <-rep(2,n_nodes) #Default to internal for all nodes
node_types[1:N] <- 1 #Assign tips 1s
node_types[root_node_id] <- 0 #Assign root 0

```

3. Get Parent and Children indices
```{r}

parent_of_node <- rep(0, n_nodes) #Asign all 0s first, equal to number of nodes
#For each child ID, will store the parent of that child, parent_of_node[child_id] = parent_id
children_of_node_list <- vector("list", n_nodes) #Create vector of list equal to the number of nodes - this will store the children of each parent node - given a parent node id, will return all child node ids
#children_of_node_list[[parent_id]] = c(child1_id, child2_id, ...)

for(i in 1:nrow(phy$edge)){ #For all branches - parent to child nodes in order of node numbers -
  parent <- phy$edge[i, 1] #Get parent node
  child <-phy$edge[i,2] #Get child node
  parent_of_node[child] <- parent #For vector of parent ids, for element = number of child, place parent id in it - returns vector with parent ID for each child ID
  children_of_node_list[[parent]] <- c(children_of_node_list[[parent]], child) #For list of child ids, for the parent node, add on all children that come from that parent node - returns list with children IDs for each parent ID - NULL for tips. Only returns immediate children of parent
}

```

4. Grab branch lengths
```{r}

branch_lengths <- rep(0.0, n_nodes)
bl_child_node_idx<-c() #Will save the ids of th child nodes in the order of the branch length vector
for(i in 1:nrow(phy$edge)){
  child_node <- phy$edge[i,2] #Save the current child node
  bl_child_node_idx<-c(bl_child_node_idx,child_node) #Saves the child IDs in order of the original tree
  branch_lengths[child_node] <- phy$edge.length[i] #For the branch length vector, for the current child node index, save the edge length - returns vector with branch lengths in order of child_nodes
}


```

5b. Set ranch Regimes - single regime
```{r}
branch_regime_idx <- rep(1,n_nodes) #Regimes for each branch in order of child node IDs
n_regs <- 1
#Choose node above - using 50 here
#parent_children_nodes<-getDescendants(phy,32) #Get all nodes that are descendent of the parent at position 32 - half the tree

#branch_regime_idx[parent_children_nodes] <- 2 #For each node, set all children from parent 32 to regime 2

#For printing tree with painted branches
edge_regimes_for_plot <- branch_regime_idx[phy$edge[,2]] #For all children, in order of tree branches, set regimes for edges for plot
reg_colors<-ggsci::pal_npg(palette=c("nrc"),alpha=1)(2) #Set colors based on pal_mpg
plot(phy,edge.color = reg_colors[edge_regimes_for_plot], edge.width = 1, cex = 0.2) #Use regime colors based on order of regimes for edges
```


6. Setup pre-order traversal - ensures all nodes are covered and parents are before children
Versus post-order in the analysis
```{r}
# --- 5. Pre-order traversal for simulation --- parents processed before children
#1. Visit the parent node
#2. Visit its children
#Root to tips order
get_pre_order_nodes <- function(tree_edge, N_tips, N_nodes, root_id) {
  pre_order <- integer(0) #Set up blank pre_order integer vector
  queue <- c(root_id) #Start with root, load it in queue
  
  while (length(queue) > 0) { #while length of queue is greater than 0
    current <- queue[1] #place queue position 1 in current
    queue <- queue[-1] #Remove position 1 from current
    pre_order <- c(pre_order, current) #Combine current parent with existing pre_order integer vector
    current_children <- tree_edge[tree_edge[,1] == current, 2] #Find all children that derive from current parent - matches
    queue <- c(queue, current_children) #Place current children into queue - this will make all children be explored, and put them in the pre_order vector
  }
  return(pre_order)
}

pre_order_node_ids <- get_pre_order_nodes(phy$edge, N, phy$Nnode, root_node_id)

```

7. Calculate current node state based on true parameters and parent parameters
```{r}
calc_current_node_state<-function(current_node, parent_node, parent_state, branch_length, regime_id_for_branch, true_H_mats, true_Sigmas, true_theta_mat){ #
  #Definitions
  
  I<-diag(n_traits) 
  #Sigma_sq_matrix <- true_Sigmas[[regime_id_for_branch]] %*% t(true_Sigmas[[regime_id_for_branch]])
  Sigma_mat <- true_Sigmas[[regime_id_for_branch]]
  H_mat <- true_H_mats[[regime_id_for_branch]]
  thetas <- true_theta_mat[,regime_id_for_branch]
  
  #1. Calculate expectation at node given specific regime
  omega <- (I - expm(-H_mat * branch_length)) %*% thetas #Mean shift along branch - t_i = branch length
  phi <-  expm(-H_mat * branch_length) #Linear dependency on ancestral state
  E_x <- omega + phi  %*% parent_state #Expectation, given state of parent
  
  #2. Calculate variance at branch give specific regime - Lyapunov Equation into a Linear System
  L <- kronecker(I, H_mat) + kronecker(H_mat,I)
  #s <- vec(Sigma_sq_matrix)
  #v <- solve(L) %*% s
  v <- solve(L, as.vector(Sigma_mat)) 
  V_stationary <- matrix(v,nrow = n_traits) #Stationary/Equlibrium V/CV Matrix
  V_i <- V_stationary - expm(-H_mat * branch_length) %*% V_stationary %*% expm(-t(H_mat) * branch_length) #Remaining variance over branch
  #For short branches, V_stationary - V_stationary, as expm(-H*ti) will be close to the identity matrix - so near 0
  V_i <- 0.5*(V_i + t(V_i)) #Make symmetrical - NEW Additions
  V_i <- V_i + 1e-10 * diag(n_traits) #Add jitter - NEW Additions
  
  node_X_state <- mvrnorm(n=1, mu = E_x,Sigma = V_i) #Simulate node state based on expectation and variance
  return(node_X_state)
}
  
```

8. Simulation loop for current node state - walk through tree from root to tips
```{r}
node_true_trait_values<-vector("list",n_nodes) #List of trait values for each node of the tree

#pre_order_node_ids - 
for (current_node in pre_order_node_ids){
  if(current_node == root_node_id){
    node_true_trait_values[[current_node]] <- true_y_root
    }
  else{
    parent_node <- parent_of_node[current_node]
    parent_state <- node_true_trait_values[[parent_node]]
    branch_length <- branch_lengths[current_node]
    regime_id_for_branch <- branch_regime_idx[current_node]
    current_node_state<-calc_current_node_state(current_node, parent_node, parent_state, branch_length, regime_id_for_branch, true_H_mats, true_Sigmas, true_theta_mat) #All it returns is the X values at each node
    node_true_trait_values[[current_node]] <- current_node_state #Save current node state
  }
}
#node_true_trait_values

```


# Display Simulated Trait values
```{r}
simulated_tip_values<-t(as.matrix(as.data.frame(node_true_trait_values)))[1:N,]
rownames(simulated_tip_values)<-phy$tip.label
colnames(simulated_tip_values)<-c("Trait1","Trait2")

y_error_sd<-0.01

simulated_tip_values <- simulated_tip_values +
  matrix(rnorm(N * n_traits, 0, y_error_sd), nrow = N, ncol = n_traits)

```


```{r}
cat("Plotting Phenogram for Trait 1...\n")
phenogram(phy, simulated_tip_values[,1], spread.labels=FALSE, fsize=0.4,
                    main = "Simulated Trait 1 Evolution"
)

```

```{r}
cat("Plotting Phenogram for Trait 2...\n")
phenogram(phy, simulated_tip_values[,2], spread.labels=FALSE, fsize=0.4,
                    main = "Simulated Trait 2 Evolution"
)
```

#########################################################################################################
# Setup for Stan Analysis
#########################################################################################################

1. Calculate post-order traversal - ensures all nodes are covered and children are visit before parents
```{r}
#Left - right - root
stack1 <-root_node_id
stack2 <- integer(0)

while(length(stack1)>0){ # LIFO (Last-In, First-Out) stack; https://www.naukri.com/code360/library/postorder-traversal-of-binary-tree
  current<-tail(stack1,n=1)
  stack1<-stack1[-length(stack1)]
  stack2<-c(current,stack2)
  stack1<-c(stack1,children_of_node_list[[current]])
}

post_order_path_nodes<-stack2


post_order_branch_lengths<-NULL
post_order_regime_idx<-NULL
post_order_node_types<-NULL

post_order_branch_lengths<-branch_lengths[post_order_path_nodes]
post_order_regime_idx<-branch_regime_idx[post_order_path_nodes]
post_order_node_types<-node_types[post_order_path_nodes]

#for (current_node in post_order_path_nodes){
#    post_order_branch_lengths <- c(post_order_branch_lengths,branch_lengths[current_node])
#    post_order_regime_idx <- c(post_order_regime_idx,branch_regime_idx[current_node])
#    post_order_node_types <-c(post_order_node_types,node_types[current_node])
#  }



```


Setup for mvBlouchOU analysis
```{r}

# Trait matrix: rows = tips, cols = traits
# Calculate mean and SD for each trait
trait_means <- colMeans(simulated_tip_values)
trait_sds   <- apply(simulated_tip_values, 2, sd)

# Standardize Y
simulated_tip_values_scaled <- scale(simulated_tip_values, 
                                     center = trait_means, 
                                     scale = trait_sds)

# 2) Define measurement error as a fraction of raw trait SDs (e.g., 5%)
measurement_fraction <- 0.05
y_error_sd <- measurement_fraction * trait_sds  # vector of length n_traits

# 3) Scale measurement error for standardized traits
# Divide per-trait error by trait SDs
y_error_scaled <- y_error_sd / trait_sds  # this gives a vector of length n_traits

# 4) Repeat error for all N tips to make matrix N x n_traits for Stan
y_error_matrix <- matrix(rep(y_error_scaled, each = N), nrow = N, ncol = length(trait_sds))

# Check results
simulated_tip_values_scaled[1:5, ]   # first 5 rows
y_error_matrix[1:5, ]                # first 5 rows

#parent_of_node - get parents of all nodes
#children_of_node_list - get immediate children of all parents
children_of_node_matrix<-matrix(unlist(children_of_node_list),ncol=2,byrow=TRUE)

#Set user defined H matix - fills columns first - 0s or 1s, where 1s are parameters to be estimated
user_H <- matrix(c(1,0
                   ,0,1),nrow = 2, ncol =2)


dat <- list(
  N = N,
  n_nodes = n_nodes,
  n_traits = n_traits,
  n_regs = n_regs,
  n_post_order_path_nodes = length(post_order_path_nodes), #Number Postorder path nodes
  n_parent_of_nodes = length(parent_of_node),
  y_obs = as.matrix(simulated_tip_values_scaled), #Using scaled data
  y_error = y_error_matrix, #Using scaled data
  
  post_order_path_nodes = post_order_path_nodes, 
  branch_lengths = branch_lengths,
  branch_regime_idx = branch_regime_idx,
  parent_of_node = parent_of_node,
  node_types = node_types,
  trait_means = trait_means, #Scaled data
  trait_sds = trait_sds,
  user_H = user_H #Set to allow for upper diagonal estimation
  )

```

###########################################################################################################################
Prior Plots
###########################################################################################################################
To visually explore what your priors look like, you can simulate a large number of samples from each prior distribution specified in your Stan model and then plot their densities or histograms.

This helps you:
1.  **Understand the implications of your prior choices**: Are they placing mass where you expect? Are they too broad or too narrow?
2.  **Diagnose potential issues**: For instance, if a scale parameter prior allows for extremely small values, it can lead to numerical instability.

These prior simulations are using the priors in Stan, but because y was standardized above, need to be back-transformed to norla space to allow comparison with the true values



Building G, Q, and T matrices as in Stan implementation - just helper functions
```{r}
build_G<- function(n_traits, i, j, angle){
    G <- diag(n_traits)
    cos_angle <- cos(angle)
    sin_angle <- sin(angle)
    G[i,i] <- cos_angle
    G[i,j] <- -sin_angle
    G[j,i] <- sin_angle
    G[j,j] <- cos_angle
    return (G)
  }

build_Q<-function(n_traits, Givens_angles){ #Iterate through Givens_angles to update Q
    Q <- diag(n_traits); #Start with identity matrix for Q
    pos <- 1;
    for(j in 2:n_traits){
      for(i in 1:(j-1)){
        Q <- Q %*% build_G(n_traits, i, j, Givens_angles[pos]);
        pos <- pos + 1;
      }
    }
    return(Q)
  }

buld_lower_tri_T<-function(n_traits, T_lower_tri){
    T_lt <- diag(n_traits) #Start with identity matrix for T
    pos <- 1
    for(j in 1:(n_traits-1)){ #Controls columns
      for(i in (j+1):n_traits){ #Controls rows
        T_lt[i,j] <- T_lower_tri[pos]
        pos <- pos + 1
        }
      }
    return (T_lt)
  }

```


Set True Values
```{r}
# Load required packages
set.seed(123)

n_sims <- 50000
n_traits <- 2

# ------------------
# Simulated "true" values from your setup - using the scaled versions
true_vals <- list(
  y_root = true_y_root,
  theta = true_theta_mat,
  H = true_H_mats[[1]],
  half_lives = true_half_lives[[1]],
  sigma_Sigma = true_sigma_Sigma,
  Omega_Sigma = true_Omega_Sigma,
  Sigma = true_Sigmas[[1]]
)

```


########################################################################################################
Set Priors
########################################################################################################

```{r}
########
#Priors
########

#Half-lives
half_lives_sim <- cbind(rlnorm(n=n_sims,log(0.5), 0.4),rlnorm(n=n_sims,log(0.5), 0.4)); #median ~0.5 time units, 

#Thetas
theta_mats_sim_scaled <-cbind(rnorm(n=n_sims, 0, 2.0),rnorm(n=n_sims, 0, 2.0))
theta_mats_sim_org<-sweep(sweep(theta_mats_sim_scaled,2,trait_sds,"*"),2,trait_means,"+")

#Y_roots
y_root_sim_scaled <- cbind(rnorm(n=n_sims,mean(theta_mats_sim_scaled) , 2.0),rnorm(n=n_sims, mean(theta_mats_sim_scaled), 2.0))
y_root_sim_org <-sweep(sweep(y_root_sim_scaled,2,trait_sds,"*"),2,trait_means,"+")


# Calculate H priors
Givens_angles <- runif(n=n_sims,-pi/2,pi/2);
T_lower_tri <- rnorm(n=n_sims,0,0.5);
#lambdas_mats_sim <- cbind(rlnorm(n=n_sims, 0.5, 0.5),rlnorm(n=n_sims, 0.5, 0.5))
#Half lives and lambdas do not change between scaled and unscaled datasets

#Calculating lambdas (diagonal of H)
lambdas_mats_sim <- cbind(log(2)/half_lives_sim[,1],log(2)/half_lives_sim[,2])

#Constructing Q
Q_list<-list()
for (i in 1:n_sims) {
  Q_list[[i]] <- build_Q(n_traits, Givens_angles[i])
}

#Constructing T
T_lower_tri_list <- list()
for (i in 1:n_sims) {
  T_lower_tri_list[[i]] <- buld_lower_tri_T(n_traits, T_lower_tri[i]) #Lower tri
  diag(T_lower_tri_list[[i]])<-lambdas_mats_sim[i,] #Diagonal o lambdas
}

#/Constructing H = Q * T * t(Q)
H_mats_sims_scaled <-list()
for (i in 1:n_sims) {
  H_mats_sims_scaled[[i]] <- Q_list[[i]] %*% T_lower_tri_list[[i]] %*% t(Q_list[[i]]) #Matrix multiplication
  }



H_mats_sims_org <-list()
D<-diag(trait_sds)
for (i in 1:n_sims) {
  H_mats_sims_org[[i]] <- D %*% H_mats_sims_scaled[[i]] %*% ginv(D)
  }


#Calculate Sigma priors
Omega_Sigma_sim <- rlkjcorr(n_sims, K = n_traits, eta = 2) #Bigger eta = more density to identity matrix, no correlation - no rescaling needed
sigma_Sigma_sim_scaled <- cbind(rlnorm(n=n_sims,1,0.5),rlnorm(n=n_sims,1,0.25)) #Mean around true values - 
#exp(1) = 2.72 - lognormal distribution
sigma_Sigma_sim_org<-sweep(sigma_Sigma_sim_scaled,2,trait_sds,"*")



# Compute full Sigma matrices - on original scale
Sigma_mats_sim_org <- lapply(1:n_sims, function(i) {
  D <- diag(sigma_Sigma_sim_org[i, ])
  D %*% Omega_Sigma_sim[i,,] %*% D
})


H_11 <- sapply(H_mats_sims_org, function(S) S[1, 1])
H_22 <- sapply(H_mats_sims_org, function(S) S[2, 2])
H_12 <- sapply(H_mats_sims_org, function(S) S[1, 2])
H_21 <- sapply(H_mats_sims_org, function(S) S[2, 1])

Sigma_11 <- sapply(Sigma_mats_sim_org, function(S) S[1, 1])
Sigma_22 <- sapply(Sigma_mats_sim_org, function(S) S[2, 2])
Sigma_12 <- sapply(Sigma_mats_sim_org, function(S) S[1, 2])
Sigma_21 <- sapply(Sigma_mats_sim_org, function(S) S[2, 1])

```

```{r}
# ------------------
# Prior Plotting function
plot_prior <- function(samples, true_value, title, xlab = "Value") {
  df <- data.frame(value = samples)
    ggplot(df, aes(x = value, fill=mypal[1])) +
    geom_density(alpha = 0.5) +
    geom_vline(xintercept = true_value, color = "black", linewidth = 1, alpha = 0.5) +
    ggtitle(title) +
    xlab(xlab) +
    #xlim(xlim) +
    theme_minimal()
}

```

```{r}
mypal <- ggsci::pal_aaas("default", alpha = 1)(3)

# ------------------
# Plot each prior with true values
plot_prior(theta_mats_sim_org[,1], t(true_vals$theta)[1], "Prior: theta[1]")
plot_prior(theta_mats_sim_org[,2], t(true_vals$theta)[2], "Prior: theta[2]")

plot_prior(y_root_sim_org[,1], true_vals$y_root[1], "Prior: y_root[1]")
plot_prior(y_root_sim_org[,2], true_vals$y_root[2], "Prior: y_root[2]")

plot_prior(half_lives_sim[, 1], true_vals$half_lives[1,1], "Prior: half_lives[1]")
plot_prior(half_lives_sim[, 2], true_vals$half_lives[2,2], "Prior: half_lives[2]")

# H matrix plots
plot_prior(H_11, true_vals$H[1, 1], "Prior: H[1,1]")
plot_prior(H_22, true_vals$H[2, 2], "Prior: H[2,2]")
plot_prior(H_12, true_vals$H[1, 2], "Prior: H[1,2]")
plot_prior(H_21, true_vals$H[2, 1], "Prior: H[2,1]")

#sigma Sigma
plot_prior(sigma_Sigma_sim_org[, 1], true_vals$sigma_Sigma[1], "Prior: true_sigma_Sigma[1]")
plot_prior(sigma_Sigma_sim_org[, 2], true_vals$sigma_Sigma[2], "Prior: true_sigma_Sigma[2]")

#Omega Sigma
plot_prior(Omega_Sigma_sim[,1,2], true_vals$Omega_Sigma[1,2], "Prior: true_Omega_Sigma[1,2]")#, xlim = c(0,5))

#Sigmas
plot_prior(Sigma_11, true_vals$Sigma[1, 1], "Prior: Sigma[1,1]")
plot_prior(Sigma_22, true_vals$Sigma[2, 2], "Prior: Sigma[2,2]")
plot_prior(Sigma_12, true_vals$Sigma[1, 2], "Prior: Sigma[1,2]")
plot_prior(Sigma_21, true_vals$Sigma[2, 1], "Prior: Sigma[2,2]")


```

#########################################################################################################################
Compile model
#########################################################################################################################

```{r}
setwd('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/')
rstan::stanc('/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch Project/Blouch Github Site/blouch/inst/stan/mvOU_mitov_1reg_user_H.stan')
stan_file<-"mvOU_mitov_1reg_user_H.stan"

stan_model<-rstan::stan_model(file=stan_file) # Compile the Stan model (this takes time the first time)
```


Debug run
```{r}
stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    chains = 1, 
    cores = 1,   
    iter = 500)

    #control = list(max_treedepth=15, adapt_delta=0.85))

```

Real run
```{r}
stan_fit <- rstan::sampling(
    object = stan_model,
    data = dat,
    chains = 2, 
    cores = 2,   
    iter = 2000)
#    , control = list(max_treedepth=12))
#, adapt_delta=0.85))

```

# Look at Posteriors
```{r}
print(stan_fit,
      pars = c("H_mats",
               "H_mats_original",
               "half_lives",
               "Sigma_mats",
               "Sigma_mats_original",
               "sigma_Sigma",
               "sigma_Sigma_original",
              "Omega_Sigma",
               "theta_mats",
              "theta_mats_original",
               "y_root",
              "y_root_original"
               ), 
      probs = c(0.025, 0.25, 0.5, 0.75, 0.975), # Default quantiles
      digits_summary = 2) # Adjust number of digits if needed

#rstan::traceplot(stan_fit, pars = c("beta","alpha","theta[1]","es","sd_theta[1]","sd_e[1]"))

post<-rstan::extract(stan_fit)
```

Posterior predictive check - compare original y with simulated y
```{r}
y_rep <- rstan::extract(stan_fit, pars="y_rep")$y_rep
bayesplot::ppc_dens_overlay(simulated_tip_values_scaled[,1], y_rep[1:50,,1])
```

# Pairs plot
```{r}
traceplot(stan_fit, pars = "lp__") #to check if any chain is stuck.

library(bayesplot)

mcmc_pairs(stan_fit,
           pars = c("H_mats_original[1,1]", "H_mats_original[2,2]", "Sigma_mats_original[1,2]", 
                    "sigma_Sigma_original[1]","sigma_Sigma_original[2]",
                    "Sigma_mats_original[1,1]", "Sigma_mats_original[1,2]", "Sigma_mats_original[2,2]",

                    "theta_mats_original[1]","theta_mats_original[2]", 
                   "Omega_Sigma[1,1]", "Omega_Sigma[2,1]","Omega_Sigma[1,2]","Omega_Sigma[2,2]",
                    "lp__" # Always include lp__ to see if divergences cluster with low likelihood
                    ),
           diag_fun = "dens", off_diag_fun = "scatter", np = nuts_params(stan_fit))

```


# Code for plotting posteriors vs. priors
```{r}
library(tidyverse)
library(tidybayes)
library(ggsci)

mypal <- pal_npg("nrc")(2)

# ------------------
# Plotting function
plot_prior_post <- function(df, title, true_val = NULL) {
  p <- ggplot(df, aes(x = value, fill = source, color = source)) +
    geom_density(alpha = 0.4, adjust = 1.2) +
    scale_fill_manual(values = mypal) +
    scale_color_manual(values = mypal) +
    labs(title = title, x = NULL, y = "Density") +
    theme_minimal(base_size = 12) +
    theme(legend.position = "top",
          plot.title = element_text(hjust = 0.5))
  
  if (!is.null(true_val)) {
    p <- p + geom_vline(xintercept = true_val,
                        color = "red", linetype = "dashed", linewidth = 0.8)
  }
  return(p)
}

```

# Extract posterior draws with tidybayes
```{r}
# ------------------
post_df <- stan_fit %>% spread_draws(
  `theta_mats_original[1]`, `theta_mats_original[2]`,
  `sigma_Sigma_original[1]`, `sigma_Sigma_original[2]`,
  `Omega_Sigma[1,2]`,
  `y_root_original[1]`, `y_root_original[2]`,
  `H_mats_original[1,1]`, `H_mats_original[2,2]`, `H_mats_original[1,2]`,`H_mats_original[2,1]`,
  `half_lives[1]`, `half_lives[2]`
)

```
# Build prior vs posterior dataframes
```{r}
# ------------------
#Half lives
#half_lives ~ lognormal(log(0.5), 0.4); // median ~0.5 time units, sensible spread
halflife1_df <- tibble(
  value = c(half_lives_sim[,1], post_df$`half_lives[1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

halflife2_df <- tibble(
  value = c(half_lives_sim[,2], post_df$`half_lives[2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# Theta
theta1_df <- tibble(
  value = c(theta_mats_sim_org[,1], post_df$`theta_mats_original[1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
theta2_df <- tibble(
  value = c(theta_mats_sim_org[,2], post_df$`theta_mats_original[2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# y_root
yroot1_df <- tibble(
  value = c(y_root_sim_org[,1], post_df$`y_root_original[1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

yroot2_df <- tibble(
  value = c(y_root_sim_org[,2], post_df$`y_root_original[2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# sigma_Sigma_original
sigma1_df <- tibble(
  value = c(sigma_Sigma_sim_org[,1], post_df$`sigma_Sigma_original[1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
sigma2_df <- tibble(
  value = c(sigma_Sigma_sim_org[,1], post_df$`sigma_Sigma_original[2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# Omega_Sigma correlation
omega12_df <- tibble(
  value = c(Omega_Sigma_sim[,1,2],
            post_df$`Omega_Sigma[1,2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

# H matrix
H11_sims_org <- sapply(H_mats_sims_org, function(mat) {
  mat[1, 1]
})
  
H22_sims_org <- sapply(H_mats_sims_org, function(mat) {
  mat[2, 2]
})
H12_sims_org <- sapply(H_mats_sims_org, function(mat) {
  mat[1, 2]
})
H21_sims_org <- sapply(H_mats_sims_org, function(mat) {
  mat[2, 1]
})
  
H11_df <- tibble(
  value = c(H11_sims_org, post_df$`H_mats_original[1,1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
H22_df <- tibble(
  value = c(H22_sims_org, post_df$`H_mats_original[2,2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

H12_df <- tibble(
  value = c(H12_sims_org, post_df$`H_mats_original[1,2]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)

H21_df <- tibble(
  value = c(H21_sims_org, post_df$`H_mats_original[2,1]`),
  source = rep(c("Prior", "Posterior"), c(n_sims, nrow(post_df)))
)
```


```{r}
# ------------------
# Make plots with true values

#true_vals set above
plot_prior_post(halflife1_df, "Halflife[1]", true_val = true_vals$half_lives[1,1])
plot_prior_post(halflife2_df, "Halflife[2]", true_val = true_vals$half_lives[2,2])

plot_prior_post(theta1_df, "Theta[1]", true_val = true_vals$theta[1,1])
plot_prior_post(theta2_df, "Theta[2]", true_val = true_vals$theta[2,1])

plot_prior_post(yroot1_df, "y_root[1]", true_val = true_vals$y_root[1])
plot_prior_post(yroot2_df, "y_root[2]", true_val = true_vals$y_root[2])

plot_prior_post(sigma1_df, "sigma_Sigma[1]", true_val = true_vals$sigma_Sigma[1])
plot_prior_post(sigma2_df, "sigma_Sigma[2]", true_val = true_vals$sigma_Sigma[2])

plot_prior_post(omega12_df, "Omega_Sigma[1,2]", true_val = true_vals$Omega_Sigma[1,2])

plot_prior_post(H11_df, "H[1,1]", true_val = true_vals$H[1,1])
plot_prior_post(H22_df, "H[2,2]", true_val = true_vals$H[2,2])
plot_prior_post(H12_df, "H[1,2]", true_val = true_vals$H[1,2])
plot_prior_post(H21_df, "H[2,1]", true_val = true_vals$H[2,1])

```



